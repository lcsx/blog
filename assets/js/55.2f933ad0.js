(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{369:function(t,n,a){"use strict";a.r(n);var e=a(28),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#多态"}},[t._v("多态")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-多态"}},[t._v("1 多态")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-1-多态的实现方式"}},[t._v("1.1 多态的实现方式")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-1-1-重写"}},[t._v("1.1.1 重写")])]),a("li",[a("a",{attrs:{href:"#_1-1-2-接口"}},[t._v("1.1.2 接口")])])])])])]),a("li",[a("a",{attrs:{href:"#接口没有构造方法。接口不饿能包含成员变量，除了static和final变量"}},[t._v("接口没有构造方法。接口不饿能包含成员变量，除了static和final变量")])]),a("li",[a("a",{attrs:{href:"#当某个空调实现了-节能-接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，我们可以直接使用一个-节能-接口类型引用的-遥控器-去指向-空调-，虽然这个-遥控器-上面只有一个按键，只有一个-变频-的方法，但是-遥控器-所指向的空调是实现了-节能-这个接口的，是有-变频-方法的实现的，我们用这个只有一个-变频-方法的遥控器去命令空调调用-变频-方法，也是行得通的"}},[t._v("当某个空调实现了“节能”接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，\n我们可以直接使用一个“节能”接口类型引用的“遥控器”去指向“空调”，虽然这个“遥控器”上面只有一个按键，只有一个“变频”的方法，\n但是“遥控器”所指向的空调是实现了“节能”这个接口的，是有“变频”方法的实现的，我们用这个只有一个“变频”方法的遥控器去命令空调调用“变频”方法，也是行得通的")])]),a("li",[a("a",{attrs:{href:"#_2-接口"}},[t._v("2 接口")]),a("ul",[a("li",[a("a",{attrs:{href:"#_2-1-接口的声明"}},[t._v("2.1 接口的声明")])]),a("li",[a("a",{attrs:{href:"#_2-2-接口的实现"}},[t._v("2.2 接口的实现")])]),a("li",[a("a",{attrs:{href:"#_2-3-不想在当前类中实现全部接口的方法"}},[t._v("2.3 不想在当前类中实现全部接口的方法")])]),a("li",[a("a",{attrs:{href:"#_2-4-接口中的常量"}},[t._v("2.4 接口中的常量")]),a("ul",[a("li",[a("a",{attrs:{href:"#_2-4-1-常量的声明"}},[t._v("2.4.1 常量的声明")])]),a("li",[a("a",{attrs:{href:"#_2-4-2-接口-与-实现类-的常量重名"}},[t._v("2.4.2 接口 与 实现类 的常量重名")])])])]),a("li",[a("a",{attrs:{href:"#_2-5-接口中的defalut-与-static"}},[t._v("2.5 接口中的defalut 与 static")]),a("ul",[a("li",[a("a",{attrs:{href:"#_2-5-1-defalut"}},[t._v("2.5.1 defalut")])]),a("li",[a("a",{attrs:{href:"#_2-5-2-多接口中方法重名解决"}},[t._v("2.5.2 多接口中方法重名解决")])]),a("li",[a("a",{attrs:{href:"#_2-6-接口的继承"}},[t._v("2.6 接口的继承")])])])])])])])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"_1-多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-多态"}},[t._v("#")]),t._v(" 1 多态")]),t._v(" "),a("p",[t._v("多态（英语：polymorphism）")]),t._v(" "),a("p",[t._v("多态是同一个行为具有多个不同表现形式或形态的能力。")]),t._v(" "),a("p",[t._v("多态就是同一个接口，使用不同的实例而执行不同操作")]),t._v(" "),a("blockquote",[a("p",[t._v("多态的必要条件")])]),t._v(" "),a("ol",[a("li",[t._v("继承;")]),t._v(" "),a("li",[t._v("重写;")]),t._v(" "),a("li",[t._v("父类引用指向子类对象.")])]),t._v(" "),a("blockquote",[a("p",[t._v("多态的优点")])]),t._v(" "),a("ol",[a("li",[t._v("消除类型之间的耦合关系")]),t._v(" "),a("li",[t._v("可替换性")]),t._v(" "),a("li",[t._v("可扩充性")]),t._v(" "),a("li",[t._v("接口性")]),t._v(" "),a("li",[t._v("灵活性")]),t._v(" "),a("li",[t._v("简化性")])]),t._v(" "),a("h3",{attrs:{id:"_1-1-多态的实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-多态的实现方式"}},[t._v("#")]),t._v(" 1.1 多态的实现方式")]),t._v(" "),a("ol",[a("li",[t._v("重写")]),t._v(" "),a("li",[t._v("接口")]),t._v(" "),a("li",[t._v("抽象类和抽象方法")])]),t._v(" "),a("h4",{attrs:{id:"_1-1-1-重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-重写"}},[t._v("#")]),t._v(" 1.1.1 重写")]),t._v(" "),a("p",[t._v("3 什么是引用指向xxx")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Salary s = new Salary("员工 A", "北京", 3, 3600.00);\nEmployee e = new Salary("员工 B", "上海", 2, 2400.00);\n\n//e 是 Employee 的引用\n// Salary 引用 s，另一个使用 Employee 引用 e\n')])])]),a("p",[t._v("父类指向子类就是")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//public class B extends A{}\n\npublic class test {\n    public static void main(String[] args) {\n        A a = new B();     //父类指向子类\n        B b = new B();\n        a.gg();            //父类的引用调用的是子类的方法\n        a.g1();\n        b.gg();\n    }\n}\n")])])]),a("h4",{attrs:{id:"_1-1-2-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-接口"}},[t._v("#")]),t._v(" 1.1.2 接口")]),t._v(" "),a("blockquote",[a("p",[t._v("问题引出\nJava中只支持单继承，")])]),t._v(" "),a("ol",[a("li",[t._v("那如何实现一个类型中兼容多种类型特征呢？")]),t._v(" "),a("li",[t._v("多种不同类型，如何有相同的特征呢？")])]),t._v(" "),a("p",[t._v("可以通过接口实现")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("接口（interface）是一个抽象类型，是抽象方法的集合，不是类。")]),t._v(" "),a("p",[t._v("接口通常已interface来声明。一个类通过继承接口的方式来继承接口的抽象方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。")]),t._v(" "),a("p",[t._v("接口无法被实化，因为接口中的方法都是抽象的，是没有方法体的")]),t._v(" "),a("h2",{attrs:{id:"接口没有构造方法。接口不饿能包含成员变量，除了static和final变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口没有构造方法。接口不饿能包含成员变量，除了static和final变量"}},[t._v("#")]),t._v(" 接口没有构造方法。接口不饿能包含成员变量，除了static和final变量")]),t._v(" "),a("blockquote",[a("p",[t._v("接口的特性")])]),t._v(" "),a("ol",[a("li",[t._v("java中没有方法体的方法需要abstract声明，但接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。")]),t._v(" "),a("li",[t._v("接口中的方法都是公有的public。")]),t._v(" "),a("li",[t._v("接口不关心类的内部数据，也不关心类里的实现方法的细节，ta之规定这些类里必须提供某些方法")]),t._v(" "),a("li",[t._v("接口里的方法都需要被实现。若是当前实现类，不完全实现接口的方法，可以将当前实现类设为抽象类abstract，然后由该类的子类来实现未实现的方法。谁类继承，谁来实现。")]),t._v(" "),a("li",[t._v("接口抽象方法不能带有主体，没有{}")]),t._v(" "),a("li",[t._v("接口不能实例化，new XX();")])]),t._v(" "),a("hr"),t._v(" "),a("blockquote",[a("p",[t._v("接口的通俗理解“空调”——“遥控器”\n可以把“节能”作为一种标准，或者说节能就是一个“接口”，这个接口中有一个方法，叫做变频方法，任何空调，如果要称得上叫做节能空调的话，那么必须实现“节能”这个接口，实现“节能”这个接口，也就必须实现“节能”接口中规定实现的“变频”方法，\n这样才算是真正的实现了“节能”这个接口，实现了“节能”这个功能。")])]),t._v(" "),a("h2",{attrs:{id:"当某个空调实现了-节能-接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，我们可以直接使用一个-节能-接口类型引用的-遥控器-去指向-空调-，虽然这个-遥控器-上面只有一个按键，只有一个-变频-的方法，但是-遥控器-所指向的空调是实现了-节能-这个接口的，是有-变频-方法的实现的，我们用这个只有一个-变频-方法的遥控器去命令空调调用-变频-方法，也是行得通的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当某个空调实现了-节能-接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，我们可以直接使用一个-节能-接口类型引用的-遥控器-去指向-空调-，虽然这个-遥控器-上面只有一个按键，只有一个-变频-的方法，但是-遥控器-所指向的空调是实现了-节能-这个接口的，是有-变频-方法的实现的，我们用这个只有一个-变频-方法的遥控器去命令空调调用-变频-方法，也是行得通的"}},[t._v("#")]),t._v(" 当某个空调实现了“节能”接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，\n我们可以直接使用一个“节能”接口类型引用的“遥控器”去指向“空调”，虽然这个“遥控器”上面只有一个按键，只有一个“变频”的方法，\n但是“遥控器”所指向的空调是实现了“节能”这个接口的，是有“变频”方法的实现的，我们用这个只有一个“变频”方法的遥控器去命令空调调用“变频”方法，也是行得通的")]),t._v(" "),a("h2",{attrs:{id:"_2-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-接口"}},[t._v("#")]),t._v(" 2 接口")]),t._v(" "),a("h3",{attrs:{id:"_2-1-接口的声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-接口的声明"}},[t._v("#")]),t._v(" 2.1 接口的声明")]),t._v(" "),a("p",[t._v('通常文件名以 "I"开头；')]),t._v(" "),a("p",[t._v("java中没有方法体的方法需要abstract声明，但接口中抽象方法可以不写abstract")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[可见度] interface 接口名称 [extends 其他的接口名] {\n        // 声明变量\n        // 抽象方法\n}\n//==============\npackage com.lcs.tel;\n\npublic abstract interface Usb {\n    //接口中抽象方法可以不写abstract\n    public void read();\n    //写全是\n    //public abstract void read();\n\n}\n\n\n")])])]),a("h3",{attrs:{id:"_2-2-接口的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-接口的实现"}},[t._v("#")]),t._v(" 2.2 接口的实现")]),t._v(" "),a("p",[t._v("当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。")]),t._v(" "),a("p",[t._v("类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。")]),t._v(" "),a("p",[t._v("一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic abstract interface Usb {\n    //接口中抽象方法可以不写abstract\n    public void read();\n    //写全是\n    //public abstract void read();\n\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// ...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n//一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n// 接口的多继承\n// public interface Hockey extends Sports, Event{}\n//============================\nimport com.lcs.tel.Iphoto;\nimport com.lcs.tel.Usb;\n//A类实现Usb接口\npublic class A implements Usb, Iphoto {\n    @Override\n    public void read(){\n        System.out.println("usb a");\n    }\n\n    @Override\n    public void takePhoto(){\n        System.out.println("paizhao");\n    }\n}\n\n\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import com.lcs.tel.Usb;\n\npublic class test {\n    public static void main(String[] args) {\n        A a = new A();//A类指向实现类\n        Usb usb1 = new A();//接口指向实现类，虽然指向A类，但ta没有A类其他的方法，只有接口里的方法\n    }\n}\n")])])]),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-3-不想在当前类中实现全部接口的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-不想在当前类中实现全部接口的方法"}},[t._v("#")]),t._v(" 2.3 不想在当前类中实现全部接口的方法")]),t._v(" "),a("p",[t._v("接口")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic interface Inet {\n    public void get1();\n    public void get2();\n}\n")])])]),a("hr"),t._v(" "),a("p",[t._v("abstract，使为抽象类，get2()方法为实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package com.lcs.tel;\n// 如果在当前类中不想实现Inet全部的方法，即只实现部分Inet的方法，需要将当前类调整为 抽象类，+ abstract\npublic abstract class B implements Inet{\n    private String name;\n    private int age;\n\n    @Override\n    public void get1() { }\n\n    public B(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n    public void showInfo(){\n        System.out.println("名字："+this.name+"\\n年龄："+this.age);\n    }\n}\n')])])]),a("hr"),t._v(" "),a("p",[t._v("子类实现接口剩下的方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic class C extends B{\n    public C(String name,int age){\n        super(name,age);\n    }\n\n    @Override\n    public void get2() { }\n}\n")])])]),a("hr"),t._v(" "),a("p",[t._v("测试")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import com.lcs.tel.B;\nimport com.lcs.tel.C;\n\npublic class test {\n    public static void main(String[] args) {\n        C c1 = new C("lcs",18);\n\n        // 多态，父类指向 子类实例\n        B b1 = new C("lcs1",22);\n\n        c1.showInfo();\n\n    }\n}\n')])])]),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-4-接口中的常量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-接口中的常量"}},[t._v("#")]),t._v(" 2.4 接口中的常量")]),t._v(" "),a("h4",{attrs:{id:"_2-4-1-常量的声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-常量的声明"}},[t._v("#")]),t._v(" 2.4.1 常量的声明")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static final PI = 3.14;\n")])])]),a("p",[t._v("在接口中可以省略，默认是public static final")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic interface Inet {\n    public void get1();\n    public void get2();\n    \n    int TEMP = 20;\n}\n\n// 调用： 类实 例.TEMP\n")])])]),a("hr"),t._v(" "),a("h4",{attrs:{id:"_2-4-2-接口-与-实现类-的常量重名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-2-接口-与-实现类-的常量重名"}},[t._v("#")]),t._v(" 2.4.2 接口 与 实现类 的常量重名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import com.lcs.tel.B;\nimport com.lcs.tel.C;\nimport com.lcs.tel.Inet;\n\npublic class test {\n    public static void main(String[] args) {\n        // 多态，父类指向 子类实例\n        B b1 = new C("lcs1",22);\n        C c1 = new C("lcs666",22);\n\n        System.out.println(b1.TEMP);    // B类中的temp值\n        System.out.println(Inet.TEMP);  //inter中的temp值\n        System.out.println(c1.TEMP);    //c中的temp值\n    }\n}\n')])])]),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-5-接口中的defalut-与-static"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-接口中的defalut-与-static"}},[t._v("#")]),t._v(" 2.5 接口中的defalut 与 static")]),t._v(" "),a("h4",{attrs:{id:"_2-5-1-defalut"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-defalut"}},[t._v("#")]),t._v(" 2.5.1 defalut")]),t._v(" "),a("p",[t._v("接口里的方法是必须要要实现的，你不想实现接口方法，但你由不得不实现这个方法。")]),t._v(" "),a("p",[t._v("java1.8中提供一个 默认实现 方式，不想改写接口的方法时。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package com.lcs.tel;\n\npublic interface Inet {\n    public void get1();\n\n    //default 是由方法体的\n    default void connection(){\n        System.out.println("接口的默认连接");\n    }\n\n    static void stop(){\n        System.out.println("接口的静态方法");\n    }\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic class C implements Inet{\n    @Override\n    public void get1() { }\n\n    @Override\n    public void connection(){\n        Inet.super.connection(); //调用接口的默认方法\n    }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import com.lcs.tel.C;\nimport com.lcs.tel.Inet;\n\npublic class test {\n    public static void main(String[] args) {\n        C c1 = new C();\n        c1.connection();\n        Inet.stop();\n    }\n}\n")])])]),a("hr"),t._v(" "),a("h4",{attrs:{id:"_2-5-2-多接口中方法重名解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-多接口中方法重名解决"}},[t._v("#")]),t._v(" 2.5.2 多接口中方法重名解决")]),t._v(" "),a("h5",{attrs:{id:"_2-5-2-1-接口与接口间重名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-1-接口与接口间重名"}},[t._v("#")]),t._v(" 2.5.2.1 接口与接口间重名")]),t._v(" "),a("p",[t._v("接口中有重名方法，在实现类中也声明一个同名的方法即可。")]),t._v(" "),a("h5",{attrs:{id:"_2-5-2-2-接口与接口、父类方法重名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-2-接口与接口、父类方法重名"}},[t._v("#")]),t._v(" 2.5.2.2 接口与接口、父类方法重名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package com.lcs.tel;\n\npublic interface Inet {\n    default void connection(){\n        System.out.println("接口的默认连接");\n    }\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package com.lcs.tel;\n\npublic interface Iphoto {\n    default void connection(){\n        System.out.println("iphoto接口的默认连接");\n    }\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package com.lcs.tel;\n\npublic class B {\n    public void connection(){\n        System.out.println("B中的connection");\n    }\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package com.lcs.tel;\n\npublic class C extends B implements Inet,Iphoto{\n\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import com.lcs.tel.C;\n\n\npublic class test {\n    public static void main(String[] args) {\n        C c1 = new C();\n        c1.connection(); //B中的connection\n    }\n}\n")])])]),a("hr"),t._v(" "),a("h5",{attrs:{id:"_2-5-3-接口变量与父类变量重名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-3-接口变量与父类变量重名"}},[t._v("#")]),t._v(" 2.5.3 接口变量与父类变量重名")]),t._v(" "),a("p",[t._v("接口方法与实现类的父类方法同名，实现类中没有该方法，则调用的是父类的方法。但是，对于接口变量与父类变量同名时，需要在实现类声明同名变量")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('interface One{\n    final int TEMP = 10;\n    default void connection(){\n        System.out.println("接口的默认连接");\n    }\n}\n\ninterface Two{\n    static int TEMP = 20;\n    void connection();\n}\n\nclass B{\n    public static final int TEMP = 30;\n    public void connection(){\n        System.out.println("B中的connection");\n    }\n}\npublic class test extends B implements One,Two{\n    public int TEMP = 40;\n    public static int LCS = 50;\n    public void show1(){\n        System.out.println(TEMP);\n    }\n    public static void main(String[] args) {\n\n        test t1 = new test();\n        t1.connection();  //B中的connection\n        t1.run();\n\n        One o1 = new test();\n        o1.connection();  //B中的connection\n\n        /*\n        * o1.run();  // One指向子类实例，但只有接口定义的方法，调用的是实现类或实现类的父类的方法。没有子类的其他方法。\n        * */\n\n        //One o2 = new B();  //报错  不兼容的类型: B无法转换为One\n\n        Two two1 = new test();\n        two1.connection();  //B中的connection\n\n        /*\n        * 接口方法与实现类的父类方法同名，实现类中没有该方法，则调用的是父类的方法。但是，对于接口变量与父类变量同名时，需要在实现类声明同名变量\n        * System.out.println(t1.TEMP);  //对TEMP的引用不明确,B 中的变量 TEMP 和 One 中的变量 TEMP 都匹配\n        * 解决 实现类中声明同名变量\n        */\n\n\n        //System.out.println(TEMP); //无法从静态上下文中引用非静态 变量 TEMP\n        //转成静态变量即可引用\n        System.out.println(LCS);  //50\n    }\n\n    public void run(){}\n}\n')])])]),a("hr"),t._v(" "),a("h4",{attrs:{id:"_2-6-接口的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-接口的继承"}},[t._v("#")]),t._v(" 2.6 接口的继承")]),t._v(" "),a("p",[t._v("java类是单继承的，但接口可以多继承。但实现类要实现接口的所有方法。")]),t._v(" "),a("p",[t._v("当前类不想完全实现接口的方法，需要转为抽象类。")]),t._v(" "),a("p",[t._v("当子接口的多个父接口有重名抽象方法，需要在子接口声明那个接口")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//写在一个文件里\n\ninterface IFather{\n    default void connection(){\n        System.out.println("IFather中的connection");\n    }\n}\n//public interface IFather{\n//    default void connection(){\n//        System.out.println("IFather中的connection");\n//    }\n//}\n// 写在一个文件里， interface前不加 public\n// 因为，类IFather是公共的, 应在名为 IFather.java 的文件中声明\n\ninterface IFather2{\n    default void connection(){\n        System.out.println("IFather2中的connection");\n    }\n}\n\ninterface ISon extends IFather2{\n    void run();\n    default void connection(){\n        System.out.println("ISon中的connection");\n    }\n}\n\npublic class test implements ISon{\n    public void run(){}\n    public static void main(String[] args) {\n        test t1 = new test();\n        t1.connection(); //实现类中未重写connection ，输出的是 ISon中的connection\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);