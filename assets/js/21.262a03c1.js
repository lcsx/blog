(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{315:function(t,a,n){t.exports=n.p+"assets/img/duizhan.1eeec592.png"},316:function(t,a,n){t.exports=n.p+"assets/img/static.21f74298.png"},382:function(t,a,n){"use strict";n.r(a);var s=n(28),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"oop面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oop面向对象"}},[t._v("#")]),t._v(" OOP面向对象")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#oop面向对象"}},[t._v("OOP面向对象")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-类和对象"}},[t._v("1 类和对象")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-1什么是面向对象"}},[t._v("1.1什么是面向对象")])]),s("li",[s("a",{attrs:{href:"#_1-2-类和对象的关系"}},[t._v("1.2 类和对象的关系")])]),s("li",[s("a",{attrs:{href:"#_1-3-单一职责原则"}},[t._v("1.3 单一职责原则")])]),s("li",[s("a",{attrs:{href:"#_1-4-不同类之间的交互"}},[t._v("1.4 不同类之间的交互")])]),s("li",[s("a",{attrs:{href:"#_1-5-对象实例化"}},[t._v("1.5 对象实例化")])]),s("li",[s("a",{attrs:{href:"#_1-6-构造方法"}},[t._v("1.6 构造方法")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-6-1-构造方法名必须和类名相同-实例化时，会调用构造方法-的例子："}},[t._v("1.6.1 构造方法名必须和类名相同.实例化时，会调用构造方法 的例子：")])]),s("li",[s("a",{attrs:{href:"#_1-6-2-构造函数分有参和无参，实例化new的时候，根据有无参数，调用不同的构造函数；类内调用方法可以省this："}},[t._v("1.6.2 构造函数分有参和无参，实例化new的时候，根据有无参数，调用不同的构造函数；类内调用方法可以省this：")])]),s("li",[s("a",{attrs:{href:"#_1-6-3-构造函数间可以相互调用，但类方法不能直接调用构造方法"}},[t._v("1.6.3 构造函数间可以相互调用，但类方法不能直接调用构造方法")])])])]),s("li",[s("a",{attrs:{href:"#_1-7-this"}},[t._v("1.7 this")])]),s("li",[s("a",{attrs:{href:"#"}})])])]),s("li",[s("a",{attrs:{href:"#_2-封装"}},[t._v("2 封装")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-1-什么是封装"}},[t._v("2.1 什么是封装")])]),s("li",[s("a",{attrs:{href:"#_2-2-封装的实现"}},[t._v("2.2 封装的实现")])]),s("li",[s("a",{attrs:{href:"#_2-3-static-静态信息符"}},[t._v("2.3 static 静态信息符")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-3-1-static-静态属性"}},[t._v("2.3.1 static 静态属性")])]),s("li",[s("a",{attrs:{href:"#_2-3-2-static-静态方法"}},[t._v("2.3.2 static 静态方法")])]),s("li",[s("a",{attrs:{href:"#_2-3-3-static-不允许的情况"}},[t._v("2.3.3 static 不允许的情况")])])])]),s("li",[s("a",{attrs:{href:"#_2-4-代码块"}},[t._v("2.4 代码块")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-4-1-代码块的执行顺序"}},[t._v("2.4.1 代码块的执行顺序")])])])]),s("li",[s("a",{attrs:{href:"#_2-5包"}},[t._v("2.5包")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-5-1-package包名"}},[t._v("2.5.1 package包名")])]),s("li",[s("a",{attrs:{href:"#_2-5-2-导入包"}},[t._v("2.5.2 导入包")])])])])])]),s("li",[s("a",{attrs:{href:"#_3-继承"}},[t._v("3 继承")]),s("ul",[s("li",[s("a",{attrs:{href:"#_3-1-继承的特点"}},[t._v("3.1 继承的特点")])]),s("li",[s("a",{attrs:{href:"#_3-2-继承的实现"}},[t._v("3.2 继承的实现")])]),s("li",[s("a",{attrs:{href:"#_3-3-方法重载"}},[t._v("3.3 方法重载")])]),s("li",[s("a",{attrs:{href:"#_3-4-方法重写"}},[t._v("3.4 方法重写")])]),s("li",[s("a",{attrs:{href:"#_3-5-访问修饰符的分类"}},[t._v("3.5 访问修饰符的分类")])]),s("li",[s("a",{attrs:{href:"#_3-6-super"}},[t._v("3.6 super")])]),s("li",[s("a",{attrs:{href:"#_3-7-继承的初始化顺序"}},[t._v("3.7 继承的初始化顺序")])]),s("li",[s("a",{attrs:{href:"#_3-8-子类中调用父类构造方法"}},[t._v("3.8 子类中调用父类构造方法")])]),s("li",[s("a",{attrs:{href:"#_3-9-super-pk-this"}},[t._v("3.9 super pk this")])]),s("li",[s("a",{attrs:{href:"#_3-10-final"}},[t._v("3.10 final")])]),s("li",[s("a",{attrs:{href:"#_3-11-注解"}},[t._v("3.11 注解")])])])])])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"_1-类和对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-类和对象"}},[t._v("#")]),t._v(" 1 类和对象")]),t._v(" "),s("p",[t._v("万物皆可对象")]),t._v(" "),s("h3",{attrs:{id:"_1-1什么是面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1什么是面向对象"}},[t._v("#")]),t._v(" 1.1什么是面向对象")]),t._v(" "),s("p",[t._v("面向对象：关注现实事物各方面的信息，从对象的角度出发，根据事物的特征来进行程序设计。")]),t._v(" "),s("ol",[s("li",[t._v("类是模子，确定对象将会有的特征（属性）和行为（方法）")]),t._v(" "),s("li",[t._v("对象是类的实例表现")]),t._v(" "),s("li",[t._v("类是对象的类型")]),t._v(" "),s("li",[t._v("对象是特定类型的数据")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-2-类和对象的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-类和对象的关系"}},[t._v("#")]),t._v(" 1.2 类和对象的关系")]),t._v(" "),s("ol",[s("li",[t._v("类是抽象的概念，是模板")]),t._v(" "),s("li",[t._v("对象是一个看得到、摸得着的具体实体")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-3-单一职责原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-单一职责原则"}},[t._v("#")]),t._v(" 1.3 单一职责原则")]),t._v(" "),s("p",[t._v("也叫单一功能原则，建议每个类有且只有要给引起功能变化的原因。也就是一个类只有一个功能。如果一个类中承担的功能越多，交融、耦合的程度越高，\n被复用的可能性越低。")]),t._v(" "),s("p",[t._v("所以，将不同功能职责放到不同的类中，也就是说把不同引发功能变化的原因封装到不同类中。就出现了拆分。")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-4-不同类之间的交互"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-不同类之间的交互"}},[t._v("#")]),t._v(" 1.4 不同类之间的交互")]),t._v(" "),s("p",[t._v("java的搜索机制：当主方法运行的时候，现在自己所在的类里查找相关的类是否存在。如果不存在，就向上找同一个包里的类。")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-5-对象实例化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-对象实例化"}},[t._v("#")]),t._v(" 1.5 对象实例化")]),t._v(" "),s("p",[t._v("声明对象和实例化对象是在内存两个不同空间里的进行的。\n0. 声明对象，如 Cat one; 是在内存栈空间里开辟了一个区域")]),t._v(" "),s("ol",[s("li",[t._v("实例化对象，如 new Cat one; 是在内存堆空间里开辟空间，完成对象初始化操作")])]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("java程序是运行在jvm虚拟机上的，jvm是java程序和操作系统的桥梁，因为jvm的存在，java可以实现平台无关性。而java的内存管理机制分配，是基于jvm来进行的。")]),t._v(" "),s("ol",[s("li",[t._v("栈是内存里的一块区域，主要保存局部变量的值；")]),t._v(" "),s("li",[t._v("堆是也是内存里的另一块区域，主要用来保存动态产生的数据，如new出来的实例化对象。")])]),t._v(" "),s("hr"),t._v(" "),s("p",[s("img",{attrs:{src:n(315),alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("a是基本数据类型，ta只在栈中开辟一块空间储存。")]),t._v(" "),s("li",[t._v("one是引用类型数据，ta占用栈和堆两个空间，栈存储指向堆的具体空间的地址。")]),t._v(" "),s("li",[t._v("栈和堆是如何关联。通过“=”赋值符号")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Cat one = new Cat();\nCat tow = one;\n")])])]),s("ol",[s("li",[t._v("Cat one在栈中开辟一个内存空间；")]),t._v(" "),s("li",[t._v("new Cat在堆中开辟一个内存空间；")]),t._v(" "),s("li",[t._v("Cat one = new Cat();将堆里的存储空间存储到栈的对象one中，也叫对象引用。")]),t._v(" "),s("li",[t._v("Cat tow = one;将引用信息复制存放到two中，two也有one的操作权。")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-6-构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-构造方法"}},[t._v("#")]),t._v(" 1.6 构造方法")]),t._v(" "),s("p",[t._v("构造方法也称 构造函数，构造器，通过构造方法完成对象的初始化设置。")]),t._v(" "),s("ol",[s("li",[t._v("构造方法名必须和类名相同.实例化时，会调用构造方法。")]),t._v(" "),s("li",[t._v("构造方法没有返回值")]),t._v(" "),s("li",[t._v("调用时必须用new。")]),t._v(" "),s("li",[t._v('当没有指定构造方法时，系统会自动添加无参而定构造方法。如没有声明"Cat.sleep()"方法，但调用了，ta自动是null')]),t._v(" "),s("li",[t._v("无参构造方法和有参构造方法可以同时出现")]),t._v(" "),s("li",[t._v("构造方法是不能被类内方法直接调用的")])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_1-6-1-构造方法名必须和类名相同-实例化时，会调用构造方法-的例子："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-1-构造方法名必须和类名相同-实例化时，会调用构造方法-的例子："}},[t._v("#")]),t._v(" 1.6.1 构造方法名必须和类名相同.实例化时，会调用构造方法 的例子：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public class Cat {\n    public Cat(){    //构造方法名必须和类名相同   \n        System.out.println("zaoshanghao lcs");\n    }\n\n    public void run(){\n        System.out.println("小猫快跑");\n    }\n\t\n}\n')])])]),s("hr"),t._v(" "),s("h4",{attrs:{id:"_1-6-2-构造函数分有参和无参，实例化new的时候，根据有无参数，调用不同的构造函数；类内调用方法可以省this："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-2-构造函数分有参和无参，实例化new的时候，根据有无参数，调用不同的构造函数；类内调用方法可以省this："}},[t._v("#")]),t._v(" 1.6.2 构造函数分有参和无参，实例化new的时候，根据有无参数，调用不同的构造函数；类内调用方法可以省this：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public class Cat {\n    String name;\n    int month;\n    double weight;\n    String species;\n\n    public Cat(){\n        System.out.println("无参构造器");\n    }\n\n    public Cat(String name){\n        System.out.println("有参构造器");\n        this.name = name;\n        run();     //  同一个类中调用，不屑this也可以\n        this.run();\n    }\n\n    public void Cat(){\n        System.out.println("我只是一个普通方法，名字恰巧叫Cat");\n    }\n    public void run(){\n        System.out.println(this.name);\n    }\n\n    public void eat(){\n        System.out.println("小猫吃鱼");\n    }\n}\n\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public class ADAS {\n    public static void main(String[] args) {\n        Cat cat1 = new Cat();  //无参构造函数\n        Cat cat2 = new Cat("lllqqq");  //有参构造函数\n        cat2.Cat();\n    }\n}\n\n/*\n无参构造器\n有参构造器\nlllqqq\nlllqqq\n我只是一个普通方法，名字恰巧叫Cat\n*/\n')])])]),s("hr"),t._v(" "),s("h4",{attrs:{id:"_1-6-3-构造函数间可以相互调用，但类方法不能直接调用构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-3-构造函数间可以相互调用，但类方法不能直接调用构造方法"}},[t._v("#")]),t._v(" 1.6.3 构造函数间可以相互调用，但类方法不能直接调用构造方法")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public class Cat {\n    String name;\n    int month;\n    double weight;\n    String species;\n\n    public Cat(){\n        System.out.println("无参构造器");\n    }\n\n    public Cat(String name){\n        this();  //对this的调用必须是构造器中的第一个语句\n//        this("lcs2",11);//报错对this的调用必须是构造器中的第一个语句，,估计也说明了this()只能有一个\n        System.out.println("有1个参构造器");\n        this.name = name;\n        this.run();\n    }\n\t\n    public Cat(String name,int month){\n        this.name = name;\n        this.month = month;\n        System.out.println("有2个参数的构造器");\n        System.out.println(this.name);\n    }\n\n    public void Cat(){\n        System.out.println("我只是一个普通方法，名字恰巧叫Cat");\n    }\n    public void run(){\n        System.out.println(this.name);\n    }\n\n    public void eat(){\n        System.out.println("小猫吃鱼");\n    }\n}\n')])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_1-7-this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-this"}},[t._v("#")]),t._v(" 1.7 this")]),t._v(" "),s("blockquote",[s("p",[t._v("就近原则")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public class Cat {\n    String name;\n\t\n    public Cat(String name){\n        name = name;\n    }\n}\n")])])]),s("ol",[s("li",[t._v("在这个有参数的构造方法的 name = name 的赋值语句中，按照就近原则，前面name就是传进来的name,name = name就是自己赋值给自己。")]),t._v(" "),s("li",[t._v('但对象中并没有 "X.name"属性。')]),t._v(" "),s("li",[t._v("当没有要赋值的变量时，才会扩大范围去找。就是解决1中例子。")]),t._v(" "),s("li",[t._v("除了解决1通过修改参数名来解决，还可以通过this关键字。this代表当前对象。")]),t._v(" "),s("li",[t._v("this的当前对象是？对调用，谁就是当前对象。就是 new XX()那个。")])]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("解决1：更改与属性名不同的变量名。但显然不是最优。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public class Cat {\n    String name;\n\t\n    public Cat(String Newname){\n        name = Newname;\n    }\n}\n")])])]),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("解决2：this关键字")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public class Cat {\n    String name;\n\t\n    public Cat(String name){\n        this.name = name;\n    }\n}\n")])])]),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("属性就近原则，同样在对象的方法上也是。\nrun()会向上查找run方法()")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public Cat(String name){\n    this.name = name;\n    run();\n    this.run();\n}\n")])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),s("h2",{attrs:{id:"_2-封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-封装"}},[t._v("#")]),t._v(" 2 封装")]),t._v(" "),s("h3",{attrs:{id:"_2-1-什么是封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是封装"}},[t._v("#")]),t._v(" 2.1 什么是封装")]),t._v(" "),s("p",[t._v("隐藏对象的信息，但留出访问的接口")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_2-2-封装的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-封装的实现"}},[t._v("#")]),t._v(" 2.2 封装的实现")]),t._v(" "),s("p",[t._v("实现步骤：")]),t._v(" "),s("ol",[s("li",[t._v("修改属性的可见性：设为 private")]),t._v(" "),s("li",[t._v("创建getter/setter方法：设为 public用于属性的读写")]),t._v(" "),s("li",[t._v("在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断。如性别输入只能男和女，数字输入只能是正数")])]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("1 private实现属性类内隐藏")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("package com.lcs.animal;\n\npublic class Cat {\n    private String name;  //\n    public int weight;\n    public Cat(String name,int weight){\n        this.name = name;\n        this.weight = weight;\n    }\n\t\n\tpublic void setName(String name){   //无返回值 void\n        this.name = name;\n    }\n\n    public String getName(){  //返回值\n        return this.name;\n    }\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('import com.lcs.animal.Cat;\n\n/**\n * author lcs\n */\npublic class ADAS {\n    public static void main(String[] args) {\n        Cat cat2 = new Cat("lllqqq",66);\n        System.out.println(cat2.weight);\n        System.out.println(cat2.name);   //由于name是私有属性，只能在类内使用，实例化后调用也是会报错的\n    }\n}\n')])])]),s("hr"),t._v(" "),s("p",[t._v("2 带参构造函数实例化也可以完成对象的属性设定，在构造方法中可以进行setter操作")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public class Cat {\n    private String name;\n    public int weight;\n    public Cat(String name,int weight){\n        this.setName(name);\n        this.weight = weight;\n    }\n\n    public void setName(String name){   //无返回值 void\n        if(name != "666"){\n            System.out.println("输入的名字必须为666");\n        }else{\n            this.name = name;\n        }\n    }\n\n    public String getName(){  //返回值\n        return this.name;\n    }\n}\n')])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_2-3-static-静态信息符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-static-静态信息符"}},[t._v("#")]),t._v(" 2.3 static 静态信息符")]),t._v(" "),s("p",[t._v("生命周期：类加载时产生，销毁时释放。生命周期长")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_2-3-1-static-静态属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-static-静态属性"}},[t._v("#")]),t._v(" 2.3.1 static 静态属性")]),t._v(" "),s("p",[t._v("Static 静态属性：")]),t._v(" "),s("ol",[s("li",[t._v("无论实例化多少个对象，staitc静态成员都是同一个内存空间，只有对象销毁时，内存才会释放；")]),t._v(" "),s("li",[t._v("所以其属性可以通过实例化后属性访问、也可以通过类属性访问，但是同样值；")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("package com.lcs.animal;\npublic class Cat{\n\tpublic static int price;\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import com.lcs.animal.Cat;\npublic class ADAS {\n    public static void main(String[] args) {\n        Cat cat2 = new Cat();\n        cat2.price = 100;\n        System.out.println(cat2.price);\n        System.out.println(Cat.price);\n    }\n}\n\n")])])]),s("hr"),t._v(" "),s("h4",{attrs:{id:"_2-3-2-static-静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-static-静态方法"}},[t._v("#")]),t._v(" 2.3.2 static 静态方法")]),t._v(" "),s("ol",[s("li",[t._v("与静态属性类似，静态方法可以通过类方法、实例化后对象名调用。推荐  类.静态成员")]),t._v(" "),s("li",[t._v("静态方法中不能直接访问同一个类中的非静态成员，只能调用同一个类中的静态成员。")]),t._v(" "),s("li",[t._v("静态方法中不能使用this")])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_2-3-3-static-不允许的情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-3-static-不允许的情况"}},[t._v("#")]),t._v(" 2.3.3 static 不允许的情况")]),t._v(" "),s("ol",[s("li",[t._v("static+类")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public static class xxx{\n\t//不可以对静态类\n}\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[t._v("局部变量使用static")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public Cat(){\n\tstatic int temp = 1;  //不允许局部变量使用static，可以用final\n}\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("静态方法/快中不能使用this")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_2-4-代码块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-代码块"}},[t._v("#")]),t._v(" 2.4 代码块")]),t._v(" "),s("p",[t._v("代码块用大括号{}")]),t._v(" "),s("h4",{attrs:{id:"_2-4-1-代码块的执行顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-代码块的执行顺序"}},[t._v("#")]),t._v(" 2.4.1 代码块的执行顺序")]),t._v(" "),s("ol",[s("li",[t._v("普通代码块：代码块出现在方法里的，是普通代码块，执行顺序是 按顺序执行")]),t._v(" "),s("li",[t._v("构造代码块：在类中定义的代码块是 构造代码块。构造代码块：创建对象时调用，优先于构造方法执行。构造代码块可以有多个，按构造代码块顺序执行")]),t._v(" "),s("li",[t._v("静态代码块：类加载调用时，")]),t._v(" "),s("li",[t._v("无论产生多少实例对象，静态代码块只执行一次！")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package com.lcs.animal;\n\npublic class Cat {\n    public static int price;\n    public Cat(){\n        System.out.println("我是构造函数");\n    }\n\t\n\tpublic void run(String name){\n\t\t{//普通代码块}\n\t}\n\t\n    { //构造代码块\n        System.out.println("我是构造代码块");  //先输出\n    }\n\t\n\tstatic{  //静态代码块\n        System.out.println("jius gan");\n    }\n}\n\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import com.lcs.animal.Cat;\n\n/**\n * author lcs\n */\npublic class ADAS {\n    public static void main(String[] args) {\n        Cat cat1 = new Cat();\n        Cat cat2 = new Cat();  //无论产生多少实例对象，静态代码块只执行一次！\n    }\n}\n")])])]),s("p",[t._v("值得注意的是，静态代码块不能访问非静态成员，若是想在静态代码块中访问非静态成员，需要实例化")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package com.lcs.animal;\n\npublic class Cat {\n    public static int price;\n    public int lcs = 66;\n\n    public Cat(){\n//        System.out.println("我是构造函数");\n    }\n\n\n    static{\n\n        price = 1000;\n        System.out.println(price); // 1000\n//      System.out.println(lcs);  //报错，同上讲，静态方法不能访问非静态成员。\n\n//        若是想在静态代码块中访问非静态成员，需要实例化\n        Cat tem = new Cat();\n        System.out.println(tem.lcs); //66\n    }\n}\n\n')])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_2-5包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5包"}},[t._v("#")]),t._v(" 2.5包")]),t._v(" "),s("p",[t._v("管理java文件、解决同名文件冲突")]),t._v(" "),s("h4",{attrs:{id:"_2-5-1-package包名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-package包名"}},[t._v("#")]),t._v(" 2.5.1 package包名")]),t._v(" "),s("ol",[s("li",[t._v("必须放在java源文件中的第一行")]),t._v(" "),s("li",[t._v("一个java源文件中只能由一个package语句")]),t._v(" "),s("li",[t._v("报名全部英文小写")]),t._v(" "),s("li",[t._v("命名方式：域名倒序+模块+功能  package com.lcs.animal;")])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_2-5-2-导入包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-导入包"}},[t._v("#")]),t._v(" 2.5.2 导入包")]),t._v(" "),s("p",[t._v("improt 包名.类名")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import com.lcs.*           //导入包中所有类\n\nimport com.lcs.nihao       //导入保重指定类\n")])])]),s("hr"),t._v(" "),s("h2",{attrs:{id:"_3-继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-继承"}},[t._v("#")]),t._v(" 3 继承")]),t._v(" "),s("p",[t._v("类与类的关系")]),t._v(" "),s("h3",{attrs:{id:"_3-1-继承的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-继承的特点"}},[t._v("#")]),t._v(" 3.1 继承的特点")]),t._v(" "),s("ol",[s("li",[t._v("一种类与类之间的关系")]),t._v(" "),s("li",[t._v("使用已存在的类的定义作为基础建立新类")]),t._v(" "),s("li",[t._v("新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类")]),t._v(" "),s("li",[t._v("单继承：一个子类只能继承一个父类")]),t._v(" "),s("li",[t._v("子类可以访问父类非私有private成员")]),t._v(" "),s("li",[t._v("父类不能访问子类成员")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-2-继承的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-继承的实现"}},[t._v("#")]),t._v(" 3.2 继承的实现")]),t._v(" "),s("p",[t._v("通过extends")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class 子类 extends 父类{\n\t...\n}\n\n")])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-3-方法重载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-方法重载"}},[t._v("#")]),t._v(" 3.3 方法重载")]),t._v(" "),s("ol",[s("li",[t._v("出现在同一个类中")]),t._v(" "),s("li",[t._v("方法名相同，参数列表不同（参数顺序、个数、类型）")]),t._v(" "),s("li",[t._v("方法返回值、访问修饰符任意")]),t._v(" "),s("li",[t._v("与方法的 参数名 无关")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-4-方法重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-方法重写"}},[t._v("#")]),t._v(" 3.4 方法重写")]),t._v(" "),s("ol",[s("li",[t._v("出现在有继承关系的子类中")]),t._v(" "),s("li",[t._v("方法名相同，参数列表相同（参数顺序、个数、类型）")]),t._v(" "),s("li",[t._v("与方法的参数名无关")]),t._v(" "),s("li",[t._v("访问修饰符，访问范围需要大于等于父类的访问范围(3.5中图片)；")]),t._v(" "),s("li",[t._v("当方法返回值是void或基本数据类型时，子类方法的返回值必须与父类的一致；但返回值是引用类型时，可以是父类或子类")]),t._v(" "),s("li",[t._v("父类的构造函数 不允许继承、不允许重写")])]),t._v(" "),s("p",[t._v("重写的概念一般用在 方法重写，但属性重写也可以。")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-5-访问修饰符的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-访问修饰符的分类"}},[t._v("#")]),t._v(" 3.5 访问修饰符的分类")]),t._v(" "),s("ol",[s("li",[t._v("private :只允许在本类中进行访问；")]),t._v(" "),s("li",[t._v("public :允许在任意位置访问")]),t._v(" "),s("li",[t._v("protected :允许在当前类、同包子类/非子类、跨包子类调用；跨包非子类不允许；")]),t._v(" "),s("li",[t._v("默认 :允许在当前类、同包子类/非子类调用;跨包子类不允许调用。")])]),t._v(" "),s("p",[s("img",{attrs:{src:n(316),alt:""}})]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-6-super"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-super"}},[t._v("#")]),t._v(" 3.6 super")]),t._v(" "),s("p",[t._v("使用场景：\n当子类重写了方法，但是子类中又想调用父类的方法时，可以通过super关键字来调用父类方法。\n同样，可以访问父类的属性")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("super.方法()   、属性\n\n")])])]),s("h3",{attrs:{id:"_3-7-继承的初始化顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-继承的初始化顺序"}},[t._v("#")]),t._v(" 3.7 继承的初始化顺序")]),t._v(" "),s("ol",[s("li",[t._v("父类静态成员（访问修饰符不影响成员加载顺序，跟书写位置有关）")]),t._v(" "),s("li",[t._v("子类静态成语")]),t._v(" "),s("li",[t._v("父类对象构造")]),t._v(" "),s("li",[t._v("子类对象构造")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-8-子类中调用父类构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-子类中调用父类构造方法"}},[t._v("#")]),t._v(" 3.8 子类中调用父类构造方法")]),t._v(" "),s("ol",[s("li",[t._v("子类的构造的过程中必须调用父类的构造方法，默认调用父类无参构造方法；")]),t._v(" "),s("li",[t._v("如果子类构造方法中你没有显式（super调用别的构造方法）标注，而父类又没有无参的构造方法，则编译出错；")]),t._v(" "),s("li",[t._v("super只能在构造方法中使用；")]),t._v(" "),s("li",[t._v("但可以通过super()调用父类构造方法，即super可以调用父类指定构造方法；")]),t._v(" "),s("li",[t._v("super()必须放在子类构造方法有效代码第一行；")])]),t._v(" "),s("p",[t._v("假如父类构造方法中，有带参构造方法 和 无参构造方法，那么子类继承父类情况下，子类实例化时能否通过有无参数来选择执行父类的代参/无参赌构造方法呢？")]),t._v(" "),s("p",[t._v('加入通过 Cat one = new Cat("xx",1); 这种是不行的。实例化时，子类构造方法默认调用的是父类无参构造方法。')]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package com.lcs.animal;\n\npublic class Animal {\n    public Animal(){\n        System.out.println("父类无参构造方法");\n    }\n\n    public Animal(String name,int month){\n        System.out.println("父类代参构造方法");\n    }\n    static{\n        System.out.println("父类静态构造方法");\n    }\n}\n\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package com.lcs.animal;\n\npublic class Cat extends Animal {\n\n    public Cat(){\n        System.out.println("子类无参构造函数");\n    }\n\n    public Cat(String name,int month){\n        System.out.println("子类带参构造函数");\n    }\n}\n\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('import com.lcs.animal.Cat;\n\n/**\n * author lcs\n */\npublic class ADAS {\n    public static void main(String[] args) {\n        Cat cat1 = new Cat("lcs",1);\n    }\n}\n\n\n/*\n父类静态构造方法\n父类无参构造方法\n子类带参构造函数\n*/\n')])])]),s("p",[t._v("但，也是可以调用父类的带参构造，通过super   完成指定构造方法的调用")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package com.lcs.animal;\n\npublic class Cat extends Animal {\n\n    public Cat(){\n        System.out.println("子类无参构造函数");\n    }\n\n    public Cat(String name,int month){\n        super(name,month);\n        System.out.println("子类带参构造函数");\n    }\n}\n\n/*\n父类静态构造方法\n父类代参构造方法\n子类带参构造函数\n*/\n')])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-9-super-pk-this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-super-pk-this"}},[t._v("#")]),t._v(" 3.9 super pk this")]),t._v(" "),s("blockquote",[s("p",[t._v("this：当前对象的引用")])]),t._v(" "),s("ol",[s("li",[t._v("访问当前类的成员方法、属性、构造方法；")]),t._v(" "),s("li",[t._v("不能在静态方法中使用")]),t._v(" "),s("li",[t._v("在构造方法中调用this()，就是调用无参构造方法；")])]),t._v(" "),s("blockquote",[s("p",[t._v("super：父类对象的引用")])]),t._v(" "),s("ol",[s("li",[t._v("访问父类成员方法、属性；")]),t._v(" "),s("li",[t._v("不能在静态方法中使用")])]),t._v(" "),s("p",[t._v("构造方法中调用this必须放到第一行，也就是说：构造方法调用时，super和this不能同时出现；")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-10-final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-10-final"}},[t._v("#")]),t._v(" 3.10 final")]),t._v(" "),s("p",[t._v("final位置不是固定的")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public final Animal(){}\n\n// final 和 public 的位置可以换，写在class前面就行了\n\nfinal public Animal(){}\n")])])]),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("final修饰变量表示不允许修改")])]),t._v(" "),s("ol",[s("li",[t._v("final + class final修饰类表示不允许被继承。")])]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("final修饰方法")])]),t._v(" "),s("ol",[s("li",[t._v("final + 方法：该方法不允许被子类重写，但可以继承；final不能修饰构造方法；")]),t._v(" "),s("li",[t._v("final 和 public 的位置可以换，写在class前面就行了；")])]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("final修饰变量表示不允许修改")])]),t._v(" "),s("ol",[s("li",[t._v("方法内局部变量使用final ：只要在具体被使用之前进行赋值即可，一旦赋值不允许被修改；")]),t._v(" "),s("li",[t._v("类成员属性使用final ： 赋值过程：1、定义直接初始化 2构造方法里完成初始化 3构造代码块完成")]),t._v(" "),s("li",[t._v("引用类型的变量:初始化之后不能再只想另一个对象；但对象的内容是可变的")])]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("配合static使用，如配置信息")])]),t._v(" "),s("p",[t._v("不想成员被修改，可以通过 static+final 实现")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('public static final String URL = "www.lcs.com"\n')])])]),s("hr"),t._v(" "),s("h3",{attrs:{id:"_3-11-注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-11-注解"}},[t._v("#")]),t._v(" 3.11 注解")]),t._v(" "),s("p",[t._v("JDK1.5版本引入的特性。可以声明再包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释")]),t._v(" "),s("p",[t._v("按照运行机制分")]),t._v(" "),s("ol",[s("li",[t._v("源码注解    ： @Override")]),t._v(" "),s("li",[t._v("编译时注解")]),t._v(" "),s("li",[t._v("运行时注解")])]),t._v(" "),s("p",[t._v("按照来源分")]),t._v(" "),s("ol",[s("li",[t._v("来自JDK的注解   ： @Override")]),t._v(" "),s("li",[t._v("来自第三方的注解")]),t._v(" "),s("li",[t._v("我们自己定义的注解")])]),t._v(" "),s("hr")])}),[],!1,null,null,null);a.default=i.exports}}]);