(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{367:function(t,n,e){"use strict";e.r(n);var a=e(28),_=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#设计模式"}},[t._v("设计模式")]),e("ul",[e("li",[e("a",{attrs:{href:"#_1-1-单例模式"}},[t._v("1.1 单例模式")]),e("ul",[e("li",[e("a",{attrs:{href:"#_1-1-1-饿汉式-单例模式"}},[t._v("1.1.1 饿汉式-单例模式")])]),e("li",[e("a",{attrs:{href:"#_1-1-2-懒汉式-单例模式"}},[t._v("1.1.2 懒汉式-单例模式")])]),e("li",[e("a",{attrs:{href:"#_1-1-3-懒汉式-pk-饿汉式"}},[t._v("1.1.3 懒汉式 PK 饿汉式")])]),e("li",[e("a",{attrs:{href:"#_1-1-4-单例模式优缺点与使用场景"}},[t._v("1.1.4 单例模式优缺点与使用场景")])])])])])])])]),t._v("\n设计模式是 一套 反复使用、多数人知晓、经过分类编目、代码设计经验的总结。"),e("p"),t._v(" "),e("p",[t._v("简单讲：软件开发任意再软件开发过程中面临的一般问题的解决方案。")]),t._v(" "),e("h2",{attrs:{id:"_1-1-单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-单例模式"}},[t._v("#")]),t._v(" 1.1 单例模式")]),t._v(" "),e("blockquote",[e("p",[t._v("目的:\n使得类的一个对象成为该类系统中的唯一实例；")])]),t._v(" "),e("blockquote",[e("p",[t._v("定义:\n一个类有且有一个实例，并且自行实例化向整个系统提供")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("要点")]),t._v(" "),e("th",[t._v("实现")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("某个类只能有一个实例")]),t._v(" "),e("td",[t._v("只提供私有的构造方法")])]),t._v(" "),e("tr",[e("td",[t._v("必须自行创建实例")]),t._v(" "),e("td",[t._v("含有一个该类的静态私有对象")])]),t._v(" "),e("tr",[e("td",[t._v("必须自行向整个系统提供这个实例")]),t._v(" "),e("td",[t._v("提供一个静态的公有方法用于创建、获取静态私有对象")])])])]),t._v(" "),e("blockquote",[e("p",[t._v("一般有两种代码实现方案")])]),t._v(" "),e("ol",[e("li",[t._v("饿汉式：对象创建过程中实例化（不管用不用，先实例化出来）")]),t._v(" "),e("li",[t._v("懒汉式：静态公有方法中实例化（用到的时候再实例化）")])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"_1-1-1-饿汉式-单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-饿汉式-单例模式"}},[t._v("#")]),t._v(" 1.1.1 饿汉式-单例模式")]),t._v(" "),e("p",[t._v("特点：空间换时间，操作速度快，但存在周期长。")]),t._v(" "),e("p",[t._v("实现：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package com.lcs.singleton;\n\npublic class SingletonOne {\n    //1.创建类中私有构造\n    private  SingletonOne(){\n        System.out.println("也会运行的");\n    }\n\n    //2.创建该类型的私有静态实例\n    private static SingletonOne instance = new SingletonOne();\n\n    //3.创建公有静态方法返回静态实例对象\n    public static SingletonOne getInstance(){\n        return instance;\n    }\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("package com.lcs.test;\n\nimport com.lcs.singleton.SingletonOne;\n\npublic class Test {\n    public static void main(String[] args) {\n        //因为SingletonOne类的构造方法是私有private，这里new会报错的。\n        //SingletonOne one = new SingletonOne();\n\n        //测试两个实例是否是同一个对象\n        SingletonOne one = SingletonOne.getInstance();\n        SingletonOne two = SingletonOne.getInstance();\n        //通过 one==two；或者对比sout（one）和sout（two）的内存地址是否相同\n        System.out.println(one);\n        System.out.println(two);\n        //结果一致 com.lcs.singleton.SingletonOne@1b6d3586\n    }\n}\n")])])]),e("hr"),t._v(" "),e("h3",{attrs:{id:"_1-1-2-懒汉式-单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-懒汉式-单例模式"}},[t._v("#")]),t._v(" 1.1.2 懒汉式-单例模式")]),t._v(" "),e("p",[t._v("时间换空间")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("package com.lcs.singleton;\n\npublic class SingletonOne {\n    //1.创建类中私有构造\n    private  SingletonOne(){}\n\n    //2.创建该类型的私有静态实例\n    private static SingletonOne instance = new SingletonOne();\n\n    //3.创建公有静态方法返回静态实例对象\n    public static SingletonOne getInstance(){\n        return instance;\n    }\n}\n")])])]),e("h3",{attrs:{id:"_1-1-3-懒汉式-pk-饿汉式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-懒汉式-pk-饿汉式"}},[t._v("#")]),t._v(" 1.1.3 懒汉式 PK 饿汉式")]),t._v(" "),e("p",[t._v("饿汉式 因为类加载的时候就进行了对象的实例化，即使是多线程并发，但访问的对象都是唯一的，所以 线程安全。")]),t._v(" "),e("p",[t._v("懒汉式存在线程风险。但在实际的开发中也有方法解决线程风险问题。")]),t._v(" "),e("ol",[e("li",[t._v("同步锁")]),t._v(" "),e("li",[t._v("双重校验锁")]),t._v(" "),e("li",[t._v("静态内部类")]),t._v(" "),e("li",[t._v("枚举")])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"_1-1-4-单例模式优缺点与使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-4-单例模式优缺点与使用场景"}},[t._v("#")]),t._v(" 1.1.4 单例模式优缺点与使用场景")]),t._v(" "),e("blockquote",[e("p",[t._v("优点")])]),t._v(" "),e("ol",[e("li",[t._v("在内存中只有一个对象，节省内存空间")]),t._v(" "),e("li",[t._v("避免频繁的创建销毁对象，提高性能")]),t._v(" "),e("li",[t._v("避免对共享资源的多重占用")])]),t._v(" "),e("blockquote",[e("p",[t._v("缺点")])]),t._v(" "),e("ol",[e("li",[t._v("扩展比较困难；")]),t._v(" "),e("li",[t._v("如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失；")])]),t._v(" "),e("blockquote",[e("p",[t._v("使用场景：")])]),t._v(" "),e("ol",[e("li",[t._v("创建对象时占用资源多，但同时有需要用到该类对象；")]),t._v(" "),e("li",[t._v("对系统内资源要求统一读写，如读写配置信息；")]),t._v(" "),e("li",[t._v("当多个实例存在可能引起程序逻辑错误，如号码生成器，如理财产品序列号")])])])}),[],!1,null,null,null);n.default=_.exports}}]);