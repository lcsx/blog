(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{380:function(n,e,t){"use strict";t.r(e);var a=t(28),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[n._v("#")]),n._v(" 内部类")]),n._v(" "),t("h2",{attrs:{id:"_1-1-什么是内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是内部类"}},[n._v("#")]),n._v(" 1.1 什么是内部类")]),n._v(" "),t("p",[n._v("在java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称内部类。")]),n._v(" "),t("h2",{attrs:{id:"为什么要内部类？内部类隐藏在外部类之内，更好的实现了信息隐藏。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要内部类？内部类隐藏在外部类之内，更好的实现了信息隐藏。"}},[n._v("#")]),n._v(" 为什么要内部类？\n内部类隐藏在外部类之内，更好的实现了信息隐藏。")]),n._v(" "),t("h2",{attrs:{id:"_1-2-内部类的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-内部类的分类"}},[n._v("#")]),n._v(" 1.2 内部类的分类")]),n._v(" "),t("ol",[t("li",[n._v("成员内部类")]),n._v(" "),t("li",[n._v("静态内部类")]),n._v(" "),t("li",[n._v("方法内部类")]),n._v(" "),t("li",[n._v("匿名内部类")])]),n._v(" "),t("hr"),n._v(" "),t("h4",{attrs:{id:"_1-2-1-成员内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-成员内部类"}},[n._v("#")]),n._v(" 1.2.1 成员内部类")]),n._v(" "),t("p",[n._v("成员内部类，也称普通内部类")]),n._v(" "),t("ol",[t("li",[n._v("内部类在外部使用时，无法直接实例化，需要借助外部类信息才能完成实例化；")]),n._v(" "),t("li",[n._v("内部类的访问修饰符，可以任意，但是访问范围会收到影响；")]),n._v(" "),t("li",[n._v("内部类可以直接访问外部类的成员；如果出现同名属性，优先访问内部类中定义的；")]),n._v(" "),t("li",[n._v("可以使用  外部类 .this.成员 的方式，访问外部类中同名的信息；")]),n._v(" "),t("li",[n._v("外部类访问内部类信息，需要通过内部类实例，无法直接访问；")]),n._v(" "),t("li",[n._v("内部类编译后.class文件命名：外部类$内部类.class")]),n._v(" "),t("li",[n._v("内部类中是否可以包含与外部类相同方法签名")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package com.lcs.tel;\n\n//外部类\npublic class Person {\n    public int age;\n    public Heart geatHeart(){\n        return new Heart();\n    }\n\n    //成员内部类\n    public class Heart{\n        public void beat(){\n            System.out.println("心跳");\n        }\n    }\n}\n')])])]),t("blockquote",[t("p",[n._v("跨包调用时，test类需要public\nnew 外部类.new 内部类\n外部实例.new 内部类")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import com.lcs.tel.Person;\n\npublic class test {\n    public static void main(String[] args) {\n        Person p1 = new Person();\n        p1.age = 18;\n\n        //获取内部类实例对象，方式1：new 外部类.new 内部类\n        Person.Heart mh = new Person().new Heart();\n\n        //方式2: 外部类对象.new 内部类\n        Person.Heart mh1 = p1.new Heart();\n\n        //方式3：自定义个方法 外部类、外部对象   .自定义获取方法\n        Person.Heart mh2 = new Person().geatHeart();\n        Person.Heart mh3 = p1.geatHeart();\n    }\n}\n")])])]),t("hr"),n._v(" "),t("h4",{attrs:{id:"_1-2-2-静态内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-静态内部类"}},[n._v("#")]),n._v(" 1.2.2 静态内部类")]),n._v(" "),t("p",[n._v("static修饰的内部类")]),n._v(" "),t("p",[n._v("总结：1、静态内部类中可以写哪些内容")]),n._v(" "),t("p",[n._v("1）匿名代码块")]),n._v(" "),t("p",[n._v("2）静态代码块")]),n._v(" "),t("p",[n._v("3）静态变量和非静态变量")]),n._v(" "),t("p",[n._v("4）静态方法和非静态方法")]),n._v(" "),t("p",[n._v("注意：不能在静态内部类中写抽象方法")]),n._v(" "),t("p",[n._v("2、外部类如何调用静态内部类中的属性和方法")]),n._v(" "),t("p",[n._v("1）外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法")]),n._v(" "),t("p",[n._v("2）外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法")]),n._v(" "),t("p",[n._v("3、静态内部类如何调用外部类的属性和方法")]),n._v(" "),t("p",[n._v("1）静态内部类可以直接调用外部类的静态属性和方法")]),n._v(" "),t("p",[n._v("2）静态内部类可以通过创建外部类实例的方法调用外部类的非静态属性和方法")]),n._v(" "),t("p",[n._v("4、如何创建静态内部类实例")]),n._v(" "),t("p",[n._v("1）在非外部类中：外部类名.内部类名 name = new 外部类名.内部类名();")]),n._v(" "),t("p",[n._v("2）在外部类中：内部类名 name = new 内部类名();")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("package com.lcs.tel;\n\n\npublic class Outer {\n    //定义一个实例变量和一个静态变量\n    private int a;\n    private static int b;\n    //定义一个静态方法和一个非静态方法\n    public static void say(){}\n    public void test(){\n        //在外部类中调用内部类的属性和方法\n        Outer.Inner.c = 1;            //可以通过静态内部类的全类名来调用静态内部类的静态属性（外部类名.静态内部类名.属性）\n        Outer.Inner.go();            //可以通过静态内部类的全类名来调用静态内部类的静态方法（外部类名.静态内部类名.方法）\n        //Outer.Inner.walk();        //不能通过类静态内部类的全类名来调用内部类的非静态属性和方法\n        Inner inner = new Inner();\n        inner.d = 1;\n        inner.walk();                    //可以通过创建内部类实例来调用静态内部类的非静态属性和方法\n    }\n    //静态内部类\n    public static class Inner{\n        //在静态内部类中定义一个静态变量和一个实例变量\n        static int c;\n        int d;\n        //定义一个匿名代码块和一个静态代码块\n        {}\n        static{}\n        //定义一个静态方法和一个普通方法\n        public static void go(){}\n        public void walk(){\n            //在静态内部类中调用外部类的属性和方法\n            int f = b;                     //可以直接调用外部类的静态属性\n            say();                        //可以直接调用外部类的静态方法\n            //int e = a;                 直接调用外部类的非静态属性出错编译出错\n            //test();                    直接调用外部类的非静态方法时编译出错\n            Outer outer = new Outer();\n            int e = outer.a;            //可以通过创建外部类实例来调用外部类的非静态属性\n            outer.test();                //可以通过创建外部类实例来调用外部类的非静态方法\n        }\n    }\n}\n")])])]),t("blockquote",[t("p",[n._v("类的内部不能直接写代码，代码只能写在方法内部")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package com.lcs.tel;\n\n//外部类\npublic class Person {\n    public int age = 22;\n    public void eat(){\n        System.out.println("吃吃吃");\n    }\n    //静态内部类\n    static class Heart{\n        public int age = 18;\n\n        // 1.想调用非静态成员，外部类非static的方法，需要通过对象实例访问\n        Person p1 = new Person();\n\n        //p1.eat(); 报错 java: 需要<标识符>  :类的内部不能直接写代码，代码只能写在方法内部，作为方法体。main是很特殊的⽅法。\n        public void lcs(){\n            p1.eat();  //就可以调用了\n        }\n\n\n\n    }\n}\n')])])]),t("hr"),n._v(" "),t("h4",{attrs:{id:"_1-2-3-方法内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-方法内部类"}},[n._v("#")]),n._v(" 1.2.3 方法内部类")]),n._v(" "),t("p",[n._v("也成局部内部类，定义在外部类方法中的内部类")]),n._v(" "),t("ol",[t("li",[n._v("方法内定义的局部变量智能在方法里使用")]),n._v(" "),t("li",[n._v("方法内不能定义静态成员")]),n._v(" "),t("li",[n._v("和方法内部成员使用规则一样，不可以用 public/private/protected/static 修饰，可以抽象类 abstract")]),n._v(" "),t("li",[n._v("类中可以包含final、abstract修饰的成员")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//外部类\npublic class Person {\n    public int age = 22;\n    public void eat(){\n        System.out.println("吃吃吃");\n    }\n\n    public Object getHeart(){\n        //定义在方法内部的类\n        class Heart{\n            public final int age = 6;\n            int temp = 22;\n\n            public final void say(){\n                System.out.println("hello");\n            }\n\n            public String beat(){\n                //调用外部类成员\n                new Person().eat();\n                return "要加油";\n            }\n        }\n        //return new Heart(); 一般很少直接返回实例，一般返回实例的方法\n        // 因为：\n        // 外部实例执行 p1= Person.getHeart()时，返回new Heart()\n        // 但 p1不能调用方法内部类的其他方法了 如say、beat方法\n        // 所以要想调用方法内部类中的方法，需要return具体的方法,如下\n        return new Heart().beat();\n    }\n\n}\n')])])]),t("hr"),n._v(" "),t("h4",{attrs:{id:"_1-2-4-匿名内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-匿名内部类"}},[n._v("#")]),n._v(" 1.2.4 匿名内部类")]),n._v(" "),t("p",[n._v("anonymous\t[əˈnɒnɪməs]\n没有名字、隐藏名字 。将类的定义与类的创建放到一起完成")]),n._v(" "),t("p",[n._v("当实例仅使用一次的时候，此时，这个类的名字就不是很重要了。")]),n._v(" "),t("p",[n._v("适用场景：")]),n._v(" "),t("ol",[t("li",[n._v("只用到类的一个实例")]),n._v(" "),t("li",[n._v("类在定以后马上用到")]),n._v(" "),t("li",[n._v("给类命名并不会使代码更容易被理解")])]),n._v(" "),t("p",[n._v("匿名内部类：")]),n._v(" "),t("ol",[t("li",[n._v("匿名内部类没有类型名称、实例对象名称")]),n._v(" "),t("li",[n._v("编译后的文件名：外部类$数字.class")]),n._v(" "),t("li",[n._v("无法使用private、public、protected、abstract、static修饰")]),n._v(" "),t("li",[n._v("无法便携构造方法，可以添加构造代码块")]),n._v(" "),t("li",[n._v("不能出现静态成员")]),n._v(" "),t("li",[n._v("匿名内部类可以实现接口，也可以继承父类，但不可兼得")])]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("根据传入的不同的人的类型，调用对应的read方法")]),n._v(" "),t("blockquote",[t("p",[n._v("先用非匿名方式实现")]),n._v(" "),t("blockquote",[t("p",[n._v("父类 抽象类")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("package com.lcs.tel;\npublic abstract class Person {\n    private String name;\n    public Person(){}\n\n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public abstract void read();\n}\n")])])]),t("blockquote",[t("blockquote",[t("p",[n._v("子类继承父类抽象类，并实现父类抽象类里的方法")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package com.lcs.tel;\n// 一个类要继承一个抽象父类，需要实现父类的所有抽象方法\npublic class Man extends Person{\n    @Override\n    public void read() {\n        System.out.println("man的read");\n    }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package com.lcs.tel;\n\npublic class Women extends Person{\n    @Override\n    public void read() {\n        System.out.println("women的read");\n    }\n}\n')])])]),t("blockquote",[t("blockquote",[t("p",[n._v("测试类\n方案1：")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import com.lcs.tel.Man;\nimport com.lcs.tel.Women;\n\npublic class test {\n    //根据传入的不同的人的类型，调用对应的read方法\n    //方案1：\n    public void getRead(Man man){\n        man.read();\n    }\n    public void getRead(Women man){\n        man.read();\n    }\n\t\n    public static void main(String[] args) {\n        //要调用getRead方法，需要先创建实例\n        test t1 = new test();\n        Man m1 = new Man();\n        Women w1 = new Women();\n        t1.getRead(m1);\n        t1.getRead(w1);\n    }\n}\n")])])]),t("p",[n._v("方案2：根据man women都是继承person类，")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("public class test {\n    //根据传入的不同的人的类型，调用对应的read方法\n\n    //方案2：根据man women都是继承person类，\n    public void getRead(Person person){\n        person.read();\n    }\n\n    public static void main(String[] args) {\n        //要调用getRead方法，需要先创建实例\n        test t1 = new test();\n        Man m1 = new Man();\n        Women w1 = new Women();\n        t1.getRead(m1);\n        t1.getRead(w1);\n    }\n}\n")])])]),t("p",[n._v("方案3：匿名类方式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('public class test {\n    //根据传入的不同的人的类型，调用对应的read方法\n\n    public void getRead(Person person){\n        person.read();\n    }\n\n    public static void main(String[] args) {\n        //要调用getRead方法，需要先创建实例\n        test t1 = new test();\n\n        //Man m1 = new Man();\n        //Women w1 = new Women();\n        //t1.getRead(m1);\n        //t1.getRead(w1);\n\n        //Person p1 = new Person(); // Person是抽象类，不能实例化\n\n        //匿名内部类\n        t1.getRead(new Person() {\n\t\t\t{\n\t\t\t\t//构造代码块\n\t\t\t}\n            @Override\n            public void read() {\n                System.out.println("man的read");\n            }\n        });\n        //只能用一次，不能复用，再想用的时候，需要重新写\n        t1.getRead(new Person() {\n            @Override\n            public void read() {\n                System.out.println("women的read");\n            }\n        });\n        //用匿名类内部类的方式，可以节省引用、内存。 如上文的m1，w1\n    }\n}\n')])])]),t("blockquote"),n._v(" "),t("p",[n._v("点击右边的一个Project Structure按钮，或者按快捷键ctrl+shift+alt+s打开工程结构窗口")])])}),[],!1,null,null,null);e.default=s.exports}}]);