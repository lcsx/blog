(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{368:function(a,t,s){"use strict";s.r(t);var e=s(28),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#_1-安装oh-my-zsh"}},[a._v("1 安装oh-my-zsh")]),s("ul",[s("li",[s("a",{attrs:{href:"#测试验证"}},[a._v("测试验证")])])])]),s("li",[s("a",{attrs:{href:"#_2-基础配置"}},[a._v("2 基础配置")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-1-查看配置信息"}},[a._v("2.1 查看配置信息")])]),s("li",[s("a",{attrs:{href:"#_2-2-设置配置信息"}},[a._v("2.2 设置配置信息")])]),s("li",[s("a",{attrs:{href:"#_2-3-修改配置信息"}},[a._v("2.3 修改配置信息")]),s("ul",[s("li",[s("a",{attrs:{href:"#_2-3-1-命令行修改配置"}},[a._v("2.3.1 命令行修改配置")])]),s("li",[s("a",{attrs:{href:"#_2-3-2-修改配置文件"}},[a._v("2.3.2 修改配置文件")])])])])])]),s("li",[s("a",{attrs:{href:"#_3-拉取远端代码：使用git命令下载远程仓库到本地"}},[a._v("3 拉取远端代码：使用Git命令下载远程仓库到本地")]),s("ul",[s("li",[s("a",{attrs:{href:"#_3-1-http-s-获取远程仓库"}},[a._v("3.1 HTTP(S)获取远程仓库")]),s("ul",[s("li",[s("a",{attrs:{href:"#_3-1-1-首次拉取"}},[a._v("3.1.1 首次拉取")])]),s("li",[s("a",{attrs:{href:"#_3-1-2-更新代码"}},[a._v("3.1.2 更新代码")])]),s("li",[s("a",{attrs:{href:"#_3-1-3-临时记住密码"}},[a._v("3.1.3 临时记住密码")])]),s("li",[s("a",{attrs:{href:"#_3-1-4-永久记住密码"}},[a._v("3.1.4 永久记住密码")])])])]),s("li",[s("a",{attrs:{href:"#_3-2-ssh拉取"}},[a._v("3.2 SSH拉取")]),s("ul",[s("li",[s("a",{attrs:{href:"#_3-2-1-尝试拉取代码"}},[a._v("3.2.1 尝试拉取代码")])]),s("li",[s("a",{attrs:{href:"#_3-2-2-创建一个ssh-key"}},[a._v("3.2.2 创建一个ssh key")])]),s("li",[s("a",{attrs:{href:"#_3-2-3-添加公钥到服务器"}},[a._v("3.2.3 添加公钥到服务器")])])])]),s("li",[s("a",{attrs:{href:"#_3-2-4-更新代码"}},[a._v("#3.2.4 更新代码")])])])]),s("li",[s("a",{attrs:{href:"#_4-提交代码：如何把修改后的代码提交到远程仓库"}},[a._v("4 提交代码：如何把修改后的代码提交到远程仓库")]),s("ul",[s("li",[s("a",{attrs:{href:"#_4-1-同步远程代码"}},[a._v("4.1 同步远程代码")])]),s("li",[s("a",{attrs:{href:"#_4-2-检查改动文件"}},[a._v("4.2 检查改动文件")])]),s("li",[s("a",{attrs:{href:"#_4-3-添加文件到缓存"}},[a._v("4.3 添加文件到缓存")])]),s("li",[s("a",{attrs:{href:"#_4-4-提交代码"}},[a._v("4.4 提交代码")])]),s("li",[s("a",{attrs:{href:"#_4-5-推送代码"}},[a._v("4.5 推送代码")])])])]),s("li",[s("a",{attrs:{href:"#_5-忽略文件权限：解决提示文件权限被修改问题"}},[a._v("5 忽略文件权限：解决提示文件权限被修改问题")]),s("ul",[s("li",[s("a",{attrs:{href:"#解决办法"}},[a._v("解决办法")])])])]),s("li",[s("a",{attrs:{href:"#_6-忽略指定文件或目录：排除项目配置文件"}},[a._v("6 忽略指定文件或目录：排除项目配置文件")]),s("ul",[s("li",[s("a",{attrs:{href:"#_6-1-问题场景"}},[a._v("6.1 问题场景")])]),s("li",[s("a",{attrs:{href:"#_6-2-忽略文件"}},[a._v("6.2 忽略文件")])]),s("li",[s("a",{attrs:{href:"#_6-3-忽略已提交文件"}},[a._v("6.3 忽略已提交文件")])]),s("li",[s("a",{attrs:{href:"#_6-4-忽略已存在的文件夹"}},[a._v("6.4 忽略已存在的文件夹")])])])]),s("li",[s("a",{attrs:{href:"#_7-图形工具使用：各系统通过图形管理git代码仓库"}},[a._v("7 图形工具使用：各系统通过图形管理Git代码仓库")]),s("ul",[s("li",[s("a",{attrs:{href:"#_7-1-安装软件"}},[a._v("7.1 安装软件")])])])]),s("li",[s("a",{attrs:{href:"#_8-分支管理：掌握快速切换分支和新建分支能力"}},[a._v("8 分支管理：掌握快速切换分支和新建分支能力")]),s("ul",[s("li",[s("a",{attrs:{href:"#_8-1-为什么要使用分支"}},[a._v("8.1 为什么要使用分支")]),s("ul",[s("li",[s("a",{attrs:{href:"#_8-1-1-没使用分支"}},[a._v("8.1.1 没使用分支")])]),s("li",[s("a",{attrs:{href:"#_8-1-2-使用了分支"}},[a._v("8.1.2 使用了分支")])])])]),s("li",[s("a",{attrs:{href:"#_8-2-查看分支"}},[a._v("8.2 查看分支")]),s("ul",[s("li",[s("a",{attrs:{href:"#_8-2-1-查看-本地-所有-的分支"}},[a._v("8.2.1 查看 本地/所有 的分支")])])])]),s("li",[s("a",{attrs:{href:"#_8-3-新建分支"}},[a._v("8.3 新建分支")]),s("ul",[s("li",[s("a",{attrs:{href:"#_8-3-1-导入远程分支"}},[a._v("8.3.1 导入远程分支")])]),s("li",[s("a",{attrs:{href:"#_8-3-2-新建本地分支"}},[a._v("8.3.2 新建本地分支")])]),s("li",[s("a",{attrs:{href:"#_8-3-3-拉取远程分支到本地分支"}},[a._v("8.3.3 拉取远程分支到本地分支")])])])]),s("li",[s("a",{attrs:{href:"#_8-4-切换分支"}},[a._v("8.4 切换分支")])])])]),s("li",[s("a",{attrs:{href:"#_9-合并分支-删除分支"}},[a._v("9 合并分支/删除分支")]),s("ul",[s("li",[s("a",{attrs:{href:"#_9-1-合并分支"}},[a._v("9.1 合并分支")])]),s("li",[s("a",{attrs:{href:"#_9-2-删除分支"}},[a._v("9.2 删除分支")]),s("ul",[s("li",[s("a",{attrs:{href:"#_9-2-1-普通删除"}},[a._v("9.2.1 普通删除")])]),s("li",[s("a",{attrs:{href:"#_9-2-2-强制删除"}},[a._v("9.2.2 强制删除")])]),s("li",[s("a",{attrs:{href:"#_9-2-3-除远程分支"}},[a._v("9.2.3 除远程分支")])]),s("li",[s("a",{attrs:{href:"#_9-2-4-查看关联失效的分支"}},[a._v("9.2.4 查看关联失效的分支")])])])])])])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"_1-安装oh-my-zsh"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-安装oh-my-zsh"}},[a._v("#")]),a._v(" 1 安装oh-my-zsh")]),a._v(" "),s("p",[a._v("安装 oh-my-zsh 的目的是为了让大家可以更快速的学习Git的命令行操作，它能够给我们在输入一些Git命令时候提供很大的方便。\n因为 oh-my-zsh 是基于 zsh，它的安装方式和系统本身有关联关系，因此统一的安装命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"\n')])])]),s("h3",{attrs:{id:"测试验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试验证"}},[a._v("#")]),a._v(" 测试验证")]),a._v(" "),s("p",[a._v("安装成功之后，会看到终端发现明显的变化，当你输入命令的一部分再按下 tab 键时，它会给你一些相应的提示或者自动补全，比如当你输入：git st\n再按下 tab 键，除了自动补全和命令提示外，还可以给你纠错")]),a._v(" "),s("h2",{attrs:{id:"_2-基础配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基础配置"}},[a._v("#")]),a._v(" 2 基础配置")]),a._v(" "),s("h3",{attrs:{id:"_2-1-查看配置信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-查看配置信息"}},[a._v("#")]),a._v(" 2.1 查看配置信息")]),a._v(" "),s("p",[a._v("在设置昵称和邮箱之前，可以先检查一下之前有没有配置过昵称和邮箱\n查看昵称的命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config user.name\n")])])]),s("p",[a._v("查看邮箱的命令如下:")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config user.email\n")])])]),s("h3",{attrs:{id:"_2-2-设置配置信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-设置配置信息"}},[a._v("#")]),a._v(" 2.2 设置配置信息")]),a._v(" "),s("p",[a._v("如果执行上面的命令没有返回相应的昵称和邮箱，说明你还没有配置昵称和邮箱。那么就需要进行配置\n配置昵称的命令参考如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('git config --global user.name "你的昵称"\n')])])]),s("p",[a._v("配置邮箱的命令参考如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('git config --global user.email "你的邮箱"\n')])])]),s("h3",{attrs:{id:"_2-3-修改配置信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-修改配置信息"}},[a._v("#")]),a._v(" 2.3 修改配置信息")]),a._v(" "),s("p",[a._v("在配置中如果不小心配置错了，或者后面想修改配置的时候，是不能通过重复执行上面的设置昵称命令，来修改昵称的，邮箱修改同理。如果你多次设置昵称，它会在命令执行后提示你无法重复配置或者可能不给你提示，但是这种情况会导致一个 key 配置了多个 value 的问题。")]),a._v(" "),s("p",[a._v("不过，修改的时候，可以通过特定的方式去修改，这里我介绍两种方法， 第一种是通过命令行，第二种是通过修改配置文件。")]),a._v(" "),s("h4",{attrs:{id:"_2-3-1-命令行修改配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-命令行修改配置"}},[a._v("#")]),a._v(" 2.3.1 命令行修改配置")]),a._v(" "),s("p",[a._v("通过命令行修改的方式比较简单，直接执行以下的命令即可\n修改昵称参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('git config --global --replace-all user.name "your user name"\n')])])]),s("p",[a._v("修改邮箱地址参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('git config --global --replace-all user.email"your user email"\n')])])]),s("h4",{attrs:{id:"_2-3-2-修改配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-修改配置文件"}},[a._v("#")]),a._v(" 2.3.2 修改配置文件")]),a._v(" "),s("p",[a._v("修改文件的方式，主要是修改位于主目录下.gitconfig 文件。在 Linux 和 Mac 中，可以通过 vim 命令进行直接编辑，比如vim ~/.gitconfig ；Windows 系统同样位于用户主目录下，假设你当前的用户是administrator，那么对应的配置文件的路径应该是 C:\\Users\\administrator.gitconfig，可以直接使用记事本修改里边的 name 或者 email。")]),a._v(" "),s("p",[a._v("如果之前已经配置过昵称和邮箱的情况下，当使用 vim 或者记事本打开配置文件之后，可以看到如下配置：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("[user]\n        name = daxia\n        email = 78778443@qq.com\n")])])]),s("p",[a._v("在如果有重复的 name 或 email，可以将其删掉，只剩下一个就好。")]),a._v(" "),s("p",[a._v("修改完，通过 git bash 输入 git config –-list可以查看是否修改成功了。")]),a._v(" "),s("h2",{attrs:{id:"_3-拉取远端代码：使用git命令下载远程仓库到本地"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-拉取远端代码：使用git命令下载远程仓库到本地"}},[a._v("#")]),a._v(" 3 拉取远端代码：使用Git命令下载远程仓库到本地")]),a._v(" "),s("h3",{attrs:{id:"_3-1-http-s-获取远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-http-s-获取远程仓库"}},[a._v("#")]),a._v(" 3.1 HTTP(S)获取远程仓库")]),a._v(" "),s("p",[a._v("HTTP 协议方式拉取代码相对来说比较简单，直接执行 git 的 clone 命令即可，不需要额外的配置，但相对 SSH协议来说安全性较低。")]),a._v(" "),s("h4",{attrs:{id:"_3-1-1-首次拉取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-首次拉取"}},[a._v("#")]),a._v(" 3.1.1 首次拉取")]),a._v(" "),s("p",[a._v("HTTP 协议首次拉取代码的命令格式如下所示")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git clone 版本库地址\t[本地文件夹名称]\n")])])]),s("p",[a._v("假设我需要把刚才新建的仓库代码拉取到本地,并且本地的文件夹名称叫httptest(也可以不指定本地文件夹名称，默认名字为远程仓库名字)，参考命令如下所示")]),a._v(" "),s("h4",{attrs:{id:"_3-1-2-更新代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-更新代码"}},[a._v("#")]),a._v(" 3.1.2 更新代码")]),a._v(" "),s("p",[a._v("假设远程代码有变更，你想把本地代码更新时，可以在本地的版本库目录下通过git pull命令更新，不需要再指定远程地址，参考命令如下")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git pull\n")])])]),s("h4",{attrs:{id:"_3-1-3-临时记住密码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-临时记住密码"}},[a._v("#")]),a._v(" 3.1.3 临时记住密码")]),a._v(" "),s("p",[a._v("如果你不想每次都输入 git 的认证信息，可以设置缓存认证数据，默认记住 15 分钟，如下命令所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config –-global credential.helper cache\n")])])]),s("p",[a._v("如果你想缓存更长时间，也可以指定缓存时长，比如下面是自定义配置记住 1 小时的命令：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config credential.helper ‘cache –timeout=3600’\n")])])]),s("h4",{attrs:{id:"_3-1-4-永久记住密码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4-永久记住密码"}},[a._v("#")]),a._v(" 3.1.4 永久记住密码")]),a._v(" "),s("p",[a._v("如果你不想每次提交代码都要输入用户名密码，也可以让 Git 永久记住密码，参考命令如下所示")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config --global credential.helper store\n")])])]),s("p",[a._v("命令执行完毕之后，会在当前用户主目录的.gitconfig文件中新增一项配置，配置如下所示")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("[credential]\n    helper = store\n")])])]),s("p",[a._v("在上面的命令中，如果没有--global，则会在当前项目下的.git/config文件增加配置")]),a._v(" "),s("h3",{attrs:{id:"_3-2-ssh拉取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-ssh拉取"}},[a._v("#")]),a._v(" 3.2 SSH拉取")]),a._v(" "),s("p",[a._v("现在我们再来看看SSH方式，相比HTTP(S)来说更加安全,因为SSH方式使用的是非对称加密，采用公钥与私钥的方式，不过相对来说配置起来会麻烦一些；好处是一次配置之后，后续不需要每次都进行认证，也更加安全。")]),a._v(" "),s("h4",{attrs:{id:"_3-2-1-尝试拉取代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-尝试拉取代码"}},[a._v("#")]),a._v(" 3.2.1 尝试拉取代码")]),a._v(" "),s("p",[a._v("ssh 方式首次拉取代码的命令没有什么变化，相比来说只是远程地址有变化，如下命令所示")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git clone git@gitee.com:songboy/test201907.git  sshtest\n")])])]),s("p",[a._v("如果没有配置公钥与私钥，所以拉取代码并没有成功。")]),a._v(" "),s("h4",{attrs:{id:"_3-2-2-创建一个ssh-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-创建一个ssh-key"}},[a._v("#")]),a._v(" 3.2.2 创建一个ssh key")]),a._v(" "),s("p",[a._v("通过 ssh 协议拉取代码首先要保证当前用户的主目录存在一个.ssh的文件夹，并且里面已经存在私钥文件，如果没有的话我们可以通过ssh-keygen，生成一份公钥与私钥，如下命令所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("ssh-keygen\n")])])]),s("p",[a._v("在执行命令的交互中，可以直接回车使用默认选项，最终会在当前用户目录下生成公钥和私钥，查看生成的公钥的命令为")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("cat ~/.ssh/id_rsa.pub\n")])])]),s("h4",{attrs:{id:"_3-2-3-添加公钥到服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-添加公钥到服务器"}},[a._v("#")]),a._v(" 3.2.3 添加公钥到服务器")]),a._v(" "),s("h3",{attrs:{id:"_3-2-4-更新代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-更新代码"}},[a._v("#")]),a._v(" #3.2.4 更新代码")]),a._v(" "),s("p",[a._v("ssh 方式更新代码命令和上面的 http 方式拉取代码命令一致，同样需要在 sshtest 目录下执行命令：git pull，然后可以看到git成功的拉取到了代码")]),a._v(" "),s("h2",{attrs:{id:"_4-提交代码：如何把修改后的代码提交到远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-提交代码：如何把修改后的代码提交到远程仓库"}},[a._v("#")]),a._v(" 4 提交代码：如何把修改后的代码提交到远程仓库")]),a._v(" "),s("h3",{attrs:{id:"_4-1-同步远程代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-同步远程代码"}},[a._v("#")]),a._v(" 4.1 同步远程代码")]),a._v(" "),s("p",[a._v("一个远程仓库有可能有多人有权限推送，所以存在远程代码比你本地仓库更新，因此在提交代码之前需要先拉取服务器代码，让本地仓库保持最新的版本记录；这样做的目的是为了防止当你提交代码之后，推送到远端出现代码冲突问题，拉取远程代码参考命令如下所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git pull \n")])])]),s("h3",{attrs:{id:"_4-2-检查改动文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-检查改动文件"}},[a._v("#")]),a._v(" 4.2 检查改动文件")]),a._v(" "),s("p",[a._v("当远端最新的代码拉下来之后，我们最好（非必须，建议每次提交前检查）通过git status命令检查一下有哪些文件被改动了，参考命令如下所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git status \n")])])]),s("p",[a._v("在终端执行完命令之后，可以看到我当前有三个文件有改动，有删除的、有添加的、也有修改内容的，图中返回的状态为英文，这里给大家翻译一下，状态有下面这几种：")]),a._v(" "),s("ol",[s("li",[a._v("Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.")]),a._v(" "),s("li",[a._v("Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作.")]),a._v(" "),s("li",[a._v("deleted： 文件已删除，本地删除，服务器上还没有删除.")]),a._v(" "),s("li",[a._v("renamed：文件名称被改变\n如果发现无意中编辑了某一个文件，但实际上并不想改变它，这里可以使用git checkout 文件名来撤销更改，参考命令如下：")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git checkout README.md\n")])])]),s("p",[a._v("撤销后，再次使用git status进行查看变动")]),a._v(" "),s("h3",{attrs:{id:"_4-3-添加文件到缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-添加文件到缓存"}},[a._v("#")]),a._v(" 4.3 添加文件到缓存")]),a._v(" "),s("p",[a._v("通过检查并将不需要改动的代码恢复后，就可以开始将需要提交的文件添加到暂存区中，添加文件到暂存区可以指定添加文件或目录，或者一次性添加全部改动到缓存。\n现在先来看看提交指定文件或目录至缓存的格式，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git add index.php\n")])])]),s("p",[a._v("上面这条命令将会把index.php这个文件提交到暂存区中去，提交后使用git status可以看到它的变化，原本 index.php 红颜色的名字变成了绿色，")]),a._v(" "),s("p",[a._v("你也可以使用刚才的命令将 app目录,提交到缓存中去，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git add app\n")])])]),s("p",[a._v("会发现 app 下的 test.php 文件被添加到缓存区域中了，如果你想一次性添加所有文件，那么可以把命令这样写")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git add .\n")])])]),s("h3",{attrs:{id:"_4-4-提交代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-提交代码"}},[a._v("#")]),a._v(" 4.4 提交代码")]),a._v(" "),s("p",[a._v("当你将所需要提交的代码都添加到缓存区域后，接下来就可以将代码提交到本地仓库中，参考命令如下所示 ：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git commit . -m “这是备注信息”\n")])])]),s("p",[a._v("上方命令中的.是代表选择所有的文件或目录，你也可以提交指定某一个文件，将.换成相应的目录或文件名即可")]),a._v(" "),s("p",[a._v("此时你再次使用git status进行查看，会发现没有文件改动列表；因为你已经将改动的文件都提交到版本记录中了；而git status是基于提交的代码最后一个版本比较的，当你提交后，两个区域的文件内容一致，所以就显示没有改动")]),a._v(" "),s("h3",{attrs:{id:"_4-5-推送代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-推送代码"}},[a._v("#")]),a._v(" 4.5 推送代码")]),a._v(" "),s("p",[a._v("当代码提交之后，在本地的工作就已经完成了，此时为了让其他人拉取你的代码，通常还需要将代码推送到远程仓库，这里我告诉大家最简单的方式，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git push\n")])])]),s("p",[a._v("查看远程地址")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git remote -v\ngit remote show origin\n")])])]),s("p",[a._v("本地分支推送到远程分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git push origin 本地分支:远程分支\n")])])]),s("h2",{attrs:{id:"_5-忽略文件权限：解决提示文件权限被修改问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-忽略文件权限：解决提示文件权限被修改问题"}},[a._v("#")]),a._v(" 5 忽略文件权限：解决提示文件权限被修改问题")]),a._v(" "),s("p",[a._v("Git 在进行版本管理的时候，默认将文件权限也包含在内，但很多时候，我们可能并不需要让文件权限保持一致。比如当我们代码发布到生产服务器中，然后修改了某个文件的权限，当我们再次拉取代码时，如果这个文件正好有代码修改，这个时候 Git 就会提示文件冲突。")]),a._v(" "),s("h3",{attrs:{id:"解决办法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[a._v("#")]),a._v(" 解决办法")]),a._v(" "),s("p",[a._v("在 Git 进行代码管理时，如果不想让 Git 记录文件权限，可以通过 Git 配置让其忽略文件权限的信息，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#当前版本库\ngit config core.filemode false\n")])])]),s("p",[a._v("如果你想让你电脑上所有的版本库，都忽略文件权限，可以在命令中加入--global，参考命令如下所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git config --global core.fileMode false\n")])])]),s("p",[a._v("当上面的命令被执行之后，就设置了忽略文件权限，此时通过cat查看配置文件.git/config，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("cat .git/config\n")])])]),s("p",[a._v("在配置文件中，如果看到fileMode false则代表配置成功")]),a._v(" "),s("h2",{attrs:{id:"_6-忽略指定文件或目录：排除项目配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-忽略指定文件或目录：排除项目配置文件"}},[a._v("#")]),a._v(" 6 忽略指定文件或目录：排除项目配置文件")]),a._v(" "),s("p",[a._v("在平时工作中可能需要把一些文件放到 Git 工作目录中，但又不想把他们提交到版本控制器里面，比如说，项目的配置文件、IDE 自己产生的目录文件等等。")]),a._v(" "),s("h3",{attrs:{id:"_6-1-问题场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-问题场景"}},[a._v("#")]),a._v(" 6.1 问题场景")]),a._v(" "),s("p",[a._v("每次提交代码之前，我都会用 git status 来查看有哪些文件有改动，但有时候，莫名其妙多出一些不是我手动增加的文件，显示为 Untracked files 状态")]),a._v(" "),s("p",[a._v("上图显示的 .DS_Store 和 .idea 是新增加的两个文件，但这两个文件并不是我手动新增加的，而是程序自动产生的，这种文件对项目没有实际意义；还有可能导致在团队协作中让两个人的代码冲突，如果直接删除这种文件也没用什么用，因为过不了多久程序又会自动产生，所以最好的办法就是让 git 对它视而不见。")]),a._v(" "),s("h3",{attrs:{id:"_6-2-忽略文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-忽略文件"}},[a._v("#")]),a._v(" 6.2 忽略文件")]),a._v(" "),s("p",[a._v("这种需求其实非常常见，因此Git本身也提供了忽略某些文件的功能，解决起来相对比较简单；我们可以在在Git工作区的根目录下创建一个.gitignore文件，把想忽略的文件名或者目录填进去，Git 就会自动忽略这些文件")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v(".DS_Store\n.idea\ntest/*\n!/test/index.php\n")])])]),s("p",[a._v("路径中会设置星号，这是表示匹配所有文件（因为后续需要排除此文件夹下的某个文件，所以这里的星号一定要加上）")]),a._v(" "),s("p",[a._v("!表示要排除的意思，因此在.gitignore文件夹中加入!也可以理解为取反的意思。")]),a._v(" "),s("h3",{attrs:{id:"_6-3-忽略已提交文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-忽略已提交文件"}},[a._v("#")]),a._v(" 6.3 忽略已提交文件")]),a._v(" "),s("p",[a._v("有的时候，可能一不小心把某一个原本应该忽略的目录提交到了版本控制器中，再使用 .gitignore 文件去忽略它的时候，发现无论如何都无法再次将其忽略，只好默默忍受；其实这是因为 Git 已经索引了该文件而导致，接下来我带着大家复现并解决此问题。")]),a._v(" "),s("p",[a._v("在.gitignore文件中加入，忽略规则，规则参考如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("test2/*\n")])])]),s("h3",{attrs:{id:"_6-4-忽略已存在的文件夹"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-忽略已存在的文件夹"}},[a._v("#")]),a._v(" 6.4 忽略已存在的文件夹")]),a._v(" "),s("h2",{attrs:{id:"_7-图形工具使用：各系统通过图形管理git代码仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-图形工具使用：各系统通过图形管理git代码仓库"}},[a._v("#")]),a._v(" 7 图形工具使用：各系统通过图形管理Git代码仓库")]),a._v(" "),s("h3",{attrs:{id:"_7-1-安装软件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-安装软件"}},[a._v("#")]),a._v(" 7.1 安装软件")]),a._v(" "),s("p",[a._v("首先，我们需要安装一个图形化的 Git 管理工具，在 Windows 中 TortoiseGit 非常流行，因此，我们在这节中主要使用它来进行讲解，主要包含主程序安装、配置向导、软件汉化三个部分。")]),a._v(" "),s("p",[a._v("下载地址：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("https://download.tortoisegit.org/tgit/2.8.0.0/TortoiseGit-2.8.0.0-64bit.msi\n")])])]),s("p",[a._v("通常傻瓜式“下一步”，")]),a._v(" "),s("p",[a._v("接着会进入一个关键的页面，小乌龟是基于 Git 的，所以这里需要你选择 Git 的安装位置，不过一般他会自动识别 Git 目录的。")]),a._v(" "),s("h2",{attrs:{id:"_8-分支管理：掌握快速切换分支和新建分支能力"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-分支管理：掌握快速切换分支和新建分支能力"}},[a._v("#")]),a._v(" 8 分支管理：掌握快速切换分支和新建分支能力")]),a._v(" "),s("h3",{attrs:{id:"_8-1-为什么要使用分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-为什么要使用分支"}},[a._v("#")]),a._v(" 8.1 为什么要使用分支")]),a._v(" "),s("h4",{attrs:{id:"_8-1-1-没使用分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-1-没使用分支"}},[a._v("#")]),a._v(" 8.1.1 没使用分支")]),a._v(" "),s("p",[a._v("在工作当中，你可能会遇到这样的情况，有一天有人告诉你线上出现紧急 BUG，需要你马上修复并上线。")]),a._v(" "),s("p",[a._v("假设我们现在是单分支在管理代码，在有人通知你修复 BUG 之前，你正在开发一个新功能，这个功能还没有开发完成，而且一时半会也没办法开发完")]),a._v(" "),s("p",[a._v("如果你在这个基础上去修复 BUG 并发布到线上去，就会把还没有开发完成的功能发布上去，这样很有可能造成新的问题。")]),a._v(" "),s("p",[a._v("所以你可能会把未开发完成的代码文件手动先备份，然后将代码回滚到线上版本，再在这个基础上去修复 BUG 上线，这种方式虽然可以实现，但显然是一个很麻烦的事情。")]),a._v(" "),s("h4",{attrs:{id:"_8-1-2-使用了分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-2-使用了分支"}},[a._v("#")]),a._v(" 8.1.2 使用了分支")]),a._v(" "),s("p",[a._v("假设我们线上生产环境用的是 master 分支，平时开发使用develop 分支开发，同样遇到这个问题的时候，我们可以基于 master 分支上复制出一个新分支取名为 temp_bug 临时分支")]),a._v(" "),s("p",[a._v("一个分支单独用来修复 BUG，确认修复无误后，再将这个分支提交的代码合并到master分支中，然后将master分支上线，就不会影响我们正在开发的新功能了。")]),a._v(" "),s("h3",{attrs:{id:"_8-2-查看分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-查看分支"}},[a._v("#")]),a._v(" 8.2 查看分支")]),a._v(" "),s("h4",{attrs:{id:"_8-2-1-查看-本地-所有-的分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-查看-本地-所有-的分支"}},[a._v("#")]),a._v(" 8.2.1 查看 本地/所有 的分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git branch \n\ngit branch -a \n")])])]),s("h3",{attrs:{id:"_8-3-新建分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-新建分支"}},[a._v("#")]),a._v(" 8.3 新建分支")]),a._v(" "),s("p",[a._v("新建分支有两种情况，第一种是远程已经有的分支，需要把它在本地也同样创建一份；还有一种是新建一个远端和本地都不存在的分支。")]),a._v(" "),s("h4",{attrs:{id:"_8-3-1-导入远程分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-1-导入远程分支"}},[a._v("#")]),a._v(" 8.3.1 导入远程分支")]),a._v(" "),s("p",[a._v("把远程分支在本地创建，可以通过 git checkout 分支名 命令进行，这个命令其实是切换分支用的。但当它发现你本地不存在这个分支，会自动找到远程对应的分支然后在本地进行创建，参考命令如下所示：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git checkout master\n")])])]),s("h4",{attrs:{id:"_8-3-2-新建本地分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-2-新建本地分支"}},[a._v("#")]),a._v(" 8.3.2 新建本地分支")]),a._v(" "),s("p",[a._v("新建一个远程和本地都不存在的分支方式，和切换分支区别不大，只需要在 git checkout 分支名 中间加入参数 -b 即可。通过这种方式，创建的分支结构和内容会与当前所在的分支一模一样，也就是说，它其实就是复制了当前的分支，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git checkout -b test\n")])])]),s("h4",{attrs:{id:"_8-3-3-拉取远程分支到本地分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-3-拉取远程分支到本地分支"}},[a._v("#")]),a._v(" 8.3.3 拉取远程分支到本地分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("# 第一种 fetch\ngit fetch origin 远程分支名:本地分支名\n\n# 第二种拉取方式，拉取远程分支到本地同时切换到刚刚拉取的分支\ngit checkout -b 本地分支名 origin/远程分支名\n#git checkout -b dev origin/dev\n")])])]),s("h3",{attrs:{id:"_8-4-切换分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-切换分支"}},[a._v("#")]),a._v(" 8.4 切换分支")]),a._v(" "),s("p",[a._v('本地lcstest分支修改文件后，想修改main分支的文件，先对lcstest分支的先\ngit add . --\x3e git commit -m "xxxx"  ，然后在切换到main分支，这样的话lcstest分支的修改的文件在main分支上就“不见”了')]),a._v(" "),s("h2",{attrs:{id:"_9-合并分支-删除分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-合并分支-删除分支"}},[a._v("#")]),a._v(" 9 合并分支/删除分支")]),a._v(" "),s("h3",{attrs:{id:"_9-1-合并分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-合并分支"}},[a._v("#")]),a._v(" 9.1 合并分支")]),a._v(" "),s("p",[a._v("将lcstest分支合并到main分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('# lcstest分支先 git add.   然后    git commit -m "xxx"\n# 再切换到main分支，在执行以下\ngit merge lcstest\n\n# 查看合并记录\ngit log\n')])])]),s("h3",{attrs:{id:"_9-2-删除分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-删除分支"}},[a._v("#")]),a._v(" 9.2 删除分支")]),a._v(" "),s("h4",{attrs:{id:"_9-2-1-普通删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-1-普通删除"}},[a._v("#")]),a._v(" 9.2.1 普通删除")]),a._v(" "),s("p",[a._v("Git 中删除分支的命令为git branch -d 分支名，其中参数-d代表的是普通删除。一般情况下，删除使用普通删除即可。普通删除相对来说比较安全，避免造成数据丢失的情况，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git branch -d test\n\n#清理远程分支\ngit push origin --delete dev\n\n")])])]),s("h4",{attrs:{id:"_9-2-2-强制删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-2-强制删除"}},[a._v("#")]),a._v(" 9.2.2 强制删除")]),a._v(" "),s("p",[a._v("在极少数情况下你可能会遇到普通删除无法将分支删除的情况，这个时候你可以将-d替换成-D，这样就可以进行强制删除，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git branch -D test\n")])])]),s("h4",{attrs:{id:"_9-2-3-除远程分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-3-除远程分支"}},[a._v("#")]),a._v(" 9.2.3 除远程分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git push origin --delete test1\n")])])]),s("p",[a._v("如果想将远程的分支与本地保持一致，直接使用 git pull 是不够的，可以使用 git remote prune origin，参考命令如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n")])])]),s("h4",{attrs:{id:"_9-2-4-查看关联失效的分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-4-查看关联失效的分支"}},[a._v("#")]),a._v(" 9.2.4 查看关联失效的分支")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("git branch -vv\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);