(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{366:function(t,e,a){"use strict";a.r(e);var s=a(28),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_10-配置多个远端仓库：把代码推送到不同的服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-配置多个远端仓库：把代码推送到不同的服务器"}},[t._v("#")]),t._v(" 10 配置多个远端仓库：把代码推送到不同的服务器")]),t._v(" "),a("p",[t._v("需要将一个改动推送到多个远程仓库去，比如说你做了一个开源项目，既想发布到 GitHub 又想发布到国内的码云上，如果建立两个文件夹分别去推送，就非常麻烦，其实 Git 已经有相关的功能")]),t._v(" "),a("p",[t._v("git push 把代码推送到远程仓库中去，其实这条命令是一条简写的命令，因为我们没有指定仓库地址，完整的命令是 git push origin，在执行简写命令时 Git 会找一个默认的仓库；如果我们想把代码往多个代码托管平台推送只需要添加一个远程地址即可，参考命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git remote add github https://github.com/78778443/gittest.git\n")])])]),a("p",[t._v("命令参数 git remote add 是添加远程仓库地址固定写法，github 是我给远程仓库自定义的一个名字，https://github.com/78778443/gittest.git 则是的远程仓库地址，命令执行完成之后，我们再使用 git remote -v 查看远程地址列表")]),t._v(" "),a("p",[t._v("已经新增了一个 github 的仓库地址，接下来，我们使用完整的推送命令把代码推送到 GitHub 的代码仓库当中去，参考推送命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git push github\n")])])]),a("h2",{attrs:{id:"_11-本地覆盖远端：把本地仓库覆盖到远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-本地覆盖远端：把本地仓库覆盖到远程仓库"}},[t._v("#")]),t._v(" 11 本地覆盖远端：把本地仓库覆盖到远程仓库")]),t._v(" "),a("p",[t._v("在使用 Git 的过程中可能会遇到这样的场景需要覆盖远程仓库，比如说，不小心把错误的代码推送到远程仓库，这个时候想把错误的代码撤销有两种方式。")]),t._v(" "),a("p",[t._v("第一种是代码层面覆盖，就是我们再次修改代码，把错误的代码纠正，然后再次提交，然后推送到远程仓库中。")]),t._v(" "),a("p",[t._v("第二种是将方式则是将记录覆盖，我们使用 git reset 版本号命令恢复到上一个版本，然后重新提交，默认情况下 Git 会拒绝你的提交，因为提交的版本号比远程仓库的落后，所以需要用上强制提交方式，也就是本节需要提到的。")]),t._v(" "),a("h3",{attrs:{id:"_11-1-覆盖远程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-覆盖远程"}},[t._v("#")]),t._v(" 11.1 覆盖远程")]),t._v(" "),a("p",[t._v("两种方式的区别是第一种方式会在 Git 中记录两个无效的提交，而第二种方式则不会显示错误的提交记录；有些情况下你可能将一些敏感信息(如数据库配置文件)不小心提交上去了，如果第一种处理方式必然会泄露出去，而第二种则可以避免。")]),t._v(" "),a("p",[t._v("第一种，代码覆盖虽然可以将代码回滚，但是提交记录仍然会被保留，所以不适合敏感信息被提交上来的情况。")]),t._v(" "),a("h3",{attrs:{id:"_11-2-记录覆盖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-记录覆盖"}},[t._v("#")]),t._v(" 11.2 记录覆盖")]),t._v(" "),a("p",[t._v("使用代码覆盖的方式虽然可以将最新的代码修改回来，但在敏感信息泄露场景下依然不能满足，如果要彻底的让记录不留痕迹，我们可以使用记录覆盖的方式。")]),t._v(" "),a("p",[t._v("首先，我们通过查看提交记录得到上一次记录 hash 值，执行的命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git log\n")])])]),a("p",[t._v("在图中可以看到，我们要把版本恢复到上上次，那么对应的 hash 值便是53029934e40db5b9f77705969902229251a8ba95，我们首先恢复到指定版本，并通过查看提交记录来判断是否恢复成功，执行命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git reset 53029934e40db5b9f77705969902229251a8ba95 && git log\n")])])]),a("p",[t._v("将代码恢复到历史版本了，接着我们使用 git push将本地仓库推送到远程，执行命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git push\n")])])]),a("p",[t._v("在图中可以看到提交并没有成功，因为提交的版本号落后于远程版本；如果我们提交需要用到强制推送命令，强制推送参考如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git push -f\n")])])]),a("p",[t._v("提交成功，至此我们将错误的提交记录已经完全覆盖销毁。")]),t._v(" "),a("h2",{attrs:{id:"_12-远端覆盖本地：把远端代码覆盖本地"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-远端覆盖本地：把远端代码覆盖本地"}},[t._v("#")]),t._v(" 12 远端覆盖本地：把远端代码覆盖本地")]),t._v(" "),a("p",[t._v("首先拉取远程最新的代码，这里不使用 git pull 而是使用 git fetch，因为 git pull 拉取远程最新分支之后，会自动对本地分支进行合并，而 git fetch 则只会拉取远程分支不进行自动合并")]),t._v(" "),a("p",[t._v("在使用 Git 的过程中，有时可能会有一些错误操作，造成分支被删除或者丢失，比如 branch -d test，如果我们想恢复此分支，可以通过 reflog 来进行恢复，不过前提是，这个 test 分支的信息没有被 git gc 清除。")]),t._v(" "),a("p",[t._v("一般情况下，除非手动执行了 git gc 命令，否则 gc 对那些无用的 object 会保留很长时间后才清除的，reflog 是 Git 提供的一个内部工具，用于记录对 Git 仓库进行的各种操作，可以使用 git reflog show 所有的管理类操作日志。")]),t._v(" "),a("h2",{attrs:{id:"_13-merge合并操作：团队协作必备技能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-merge合并操作：团队协作必备技能"}},[t._v("#")]),t._v(" 13 merge合并操作：团队协作必备技能")]),t._v(" "),a("p",[t._v("以我公司为例，有三个分支，develop、test、master三个分支；develop为开发分支，日常在这个分支下开发功能，test分支为功能测试分支，面向测试同事，master分支为生产环境的代码，面向用户；")]),t._v(" "),a("p",[t._v("在接到新功能之后，大家会在 develop 分支下共同开发，觉得没问题之后，会通过git merge将 develop 代码合并到 test 分支中，然后发布到测试服务器，当测试通过后，会再次将 test 分支的代码合并到 master 分支中去。")]),t._v(" "),a("h3",{attrs:{id:"_13-1-合并代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-合并代码"}},[t._v("#")]),t._v(" 13.1 合并代码")]),t._v(" "),a("p",[t._v("为了让测试人员能够测试到我们开发的功能，我们需要将develop分支的新版本同步到test分支中，这个同步的过程有多种方式，但最常见的就是使用git merge命令，也就是合并代码操作；\n在执行代码合并的时候，我们需要将分支切换到test分支上，执行命令如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git checkout  test \n")])])]),a("p",[t._v("成功切换到test分支中，现在就可以使用git merge命令将develop分支合并到test分支中，执行的命令如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git merge develop\n")])])]),a("h3",{attrs:{id:"_13-2-冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-冲突"}},[t._v("#")]),t._v(" 13.2 冲突")]),t._v(" "),a("p",[t._v("冲突符号以<<<<<<开始，以======符号为分界符号，上面的是当前test的，下面的是develop分支的，最后以>>>>>>为结束符；\n我们需要删除多余代码和冲突发，只保留我们需要在当前分支需要保留的内容即可，删除多余的内容")]),t._v(" "),a("p",[t._v("解决冲突后这里提交版本的方式稍微有一些区别，会在git commit 后面增加一个-a参数，而且不需要-m参数；但是执行之后会单独多出一个步骤让你填写冲突解决的备注信息")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git add .  && git commit -a\n")])])]),a("h3",{attrs:{id:"_13-3-gitattributes避免冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-3-gitattributes避免冲突"}},[t._v("#")]),t._v(" 13.3 .gitattributes避免冲突")]),t._v(" "),a("p",[t._v("需要针对配置文件config.php文件做一些配置，这里需要用到一个 Git 仓库当中的特殊文件.gitattributes和之前的忽略文件类似，它们都是 Git 中的一个特殊文件;我们在里面增加文件并设置参数，当 Git 在触发动作的时候会检查这个规则列表，比如我们接下来设置merge=ours的参数便是合并是排除它")]),t._v(" "),a("p",[t._v(".gitattributes文件里面写入/config/config.php merge=ours")]),t._v(" "),a("h3",{attrs:{id:"_13-4-合并代码到正式环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-合并代码到正式环境"}},[t._v("#")]),t._v(" 13.4 合并代码到正式环境")]),t._v(" "),a("p",[t._v("假设此时测试人员测试通过后，我们需要将代码发布到正式的生产环境，我们这个时候就切换到 master 分支中去，然后进行合并代码，此时 master 应该从 test 分支中进行合并，而不是从 develop 分支合并，因为 test 分支才是稳定的版本，切换到master分支，")]),t._v(" "),a("p",[t._v("接下来我们把 test 分支合并到 master 分支中去，执行的命令如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git merge test\n")])])]),a("h2",{attrs:{id:"_14-客户端钩子使用：提交代码时触发事件案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-客户端钩子使用：提交代码时触发事件案例"}},[t._v("#")]),t._v(" 14 客户端钩子使用：提交代码时触发事件案例")]),t._v(" "),a("p",[t._v("有些时候，我们想在提交版本时候触发一些事件，触发事件的这个动作我们称之为钩子。 在 Git 中有两种类型的钩子，分别是客户端的和服务器端的。 客户端钩子主要是提交和合并这些的操作所调用，服务器端钩子主要是在接收被推送的提交这样的操作。")]),t._v(" "),a("h3",{attrs:{id:"_14-1-认识钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-认识钩子"}},[t._v("#")]),t._v(" 14.1 认识钩子")]),t._v(" "),a("p",[t._v("Git 客户端钩子存储在 .git/hooks 目录中，在你初始化一个 Git 仓库时候这个目录便会产生，同时还会在里面放一些示例脚本，这些脚本都是以.sample结尾，我们可以使用 ls 命令查看一下，执行命令如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ls .git/hooks\n")])])]),a("p",[t._v("可以看出，有很多个钩子示例文件，这些钩子分别会在不同的事件中被触发")]),t._v(" "),a("p",[t._v("示例钩子都是shell脚本，部分钩子示例混杂了 Perl 代码，不过只要命名正确的可执行脚本都可以使用，比如 Python 或其它语言编写")]),t._v(" "),a("h3",{attrs:{id:"_14-2-钩子触发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-钩子触发"}},[t._v("#")]),t._v(" 14.2 钩子触发")]),t._v(" "),a("p",[t._v("|钩子名字\t\t\t|触发时间\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n|pre-commit\t\t\t|执行git commit命令完成前被执行。\t\t\t\t\t\t\t\t\t\t|\n|prepare-commit-msg\t|在执行完pre-commit钩子之后被调用。\t\t\t\t\t\t\t\t\t\t|\n|commit-msg\t\t\t|git commit执行完成后被调用。\t\t\t\t\t\t\t\t\t\t\t|\n|post-commit\t\t|post-commit钩子在commit-msg钩子之后立即被运行 。\t\t\t\t\t\t|\n|post-checkout\t\t|post-checkout钩子在使用git checkout命令时候会被调用。\t\t\t\t\t|\n|pre-rebase\t\t\t|pre-rebase钩子在使用git rebase命令发生更改之前运行\t\t\t\t\t\t|\n|pre-receive\t\t|pre-receive钩子在有人用git push向仓库推送代码时被执行。\t\t\t\t|\n|update\t\t\t\t|update钩子在pre-receive之后被调用，分别被每个推送上来的引用分别调用。\t|\n|post-receive\t\t|在成功推送后被调用，适合用于发送通知。\t\t\t\t\t\t\t\t\t|")])])}),[],!1,null,null,null);e.default=r.exports}}]);